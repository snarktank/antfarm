<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Antfarm RTS Command Grid</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Orbitron:wght@500;700&family=Geist+Mono&display=swap" rel="stylesheet">
<style>
:root {
  --bg-a:#050913;
  --bg-b:#081325;
  --bg-c:#0a1a31;
  --corpus-ice:#e6fbff;
  --corpus-teal:#6ff8ff;
  --corpus-blue:#68c7ff;
  --corpus-line:#7fcbff5a;
  --panel:#0b1a2dcc;
  --panel-edge:#73c7ff55;
  --muted:#8aa3be;
  --ok:#4df5bf;
  --warn:#ffd06b;
  --bad:#ff7198;
}
* { box-sizing:border-box; margin:0; padding:0; }
body {
  font-family:Inter,system-ui,sans-serif;
  color:var(--corpus-ice);
  min-height:100vh;
  overflow:hidden;
  background:
    radial-gradient(circle at 12% 12%, #1e3258 0%, #0b1528 24%, transparent 52%),
    radial-gradient(circle at 88% 18%, #163755 0%, #0a1426 25%, transparent 58%),
    linear-gradient(165deg,var(--bg-c) 0%,var(--bg-b) 45%,var(--bg-a) 100%);
}
.notice { font-size:11px; color:var(--muted); }
button,select,input,textarea {
  border:1px solid #4f799f;
  background:#0b1b30;
  color:var(--corpus-ice);
  border-radius:8px;
  padding:7px 10px;
}
button { cursor:pointer; }
button:hover { border-color:#8de7ff; box-shadow:0 0 0 1px #95e6ff44 inset; }
.layout { position:relative; width:100vw; height:100vh; }
.world-wrap {
  position:relative;
  inset:0;
  width:100%;
  height:100%;
  overflow:hidden;
  background:#050913;
}
.world-bg {
  position:absolute; inset:0;
  background-image:url('/rts-sprites/bg-dark-tile-test.png?v=20260212b');
  background-repeat:repeat;
  background-size:128px 128px;
  background-position:calc(var(--cam-x, 0px) * -0.75) calc(var(--cam-y, 0px) * -0.75);
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.world {
  position:absolute;
  inset:0;
}
.path-layer {
  pointer-events:none;
}
.rts-path {
  position:absolute;
  height:2px;
  transform-origin:left center;
  border-radius:999px;
  background:linear-gradient(90deg,#5ec8ff55 0%, #89efffaa 48%, #5ec8ff44 100%);
  box-shadow:0 0 8px #6ad8ff55;
}
.rts-path.active {
  background:linear-gradient(90deg,#77ffd899 0%, #8fd8ffcc 48%, #77ffd888 100%);
  box-shadow:0 0 14px #76ffe099;
}
.build-note {
  position:absolute;
  min-width:130px;
  max-width:220px;
  border:1px solid #79dcffb2;
  border-radius:8px;
  background:#0a1f34ee;
  padding:6px 8px;
  color:#dff8ff;
  font-size:10px;
  line-height:1.25;
  box-shadow:0 6px 14px #00000077;
  pointer-events:auto;
}
.build-note a {
  color:#95f1ff;
  text-decoration:none;
  border-bottom:1px solid #95f1ff66;
}
.panel {
  background:var(--panel);
  border:1px solid var(--panel-edge);
  border-radius:12px;
  padding:12px;
}
.panel h3 {
  font-family:Orbitron,sans-serif;
  font-size:12px;
  letter-spacing:.5px;
  margin-bottom:9px;
  color:var(--corpus-teal);
}
.hud {
  position:absolute;
  top:12px;
  left:12px;
  right:12px;
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:10px;
  pointer-events:none;
  z-index:50;
}
.hud-left,
.hud-right { display:flex; gap:8px; pointer-events:auto; }
.hud-right { flex-direction:column; width:min(360px, 34vw); max-height:calc(100vh - 24px); overflow:auto; }
.layout.feature-mode .hud-right { width:min(560px, 52vw); max-height:calc(100vh - 24px); }
.layout.feature-mode #livePanel,
.layout.feature-mode #selectionPanel { display:none; }
.layout.feature-mode #actionPanel { min-height:calc(100vh - 120px); }
.command-bar {
  position:absolute;
  left:50%;
  bottom:12px;
  transform:translateX(-50%);
  border:1px solid var(--panel-edge);
  border-radius:12px;
  background:linear-gradient(180deg,#09172d,#081224);
  display:flex;
  align-items:center;
  width:min(760px, calc(100vw - 24px));
  z-index:60;
}
.command-left {
  display:none;
}
.command-title { font-family:Orbitron,sans-serif; font-size:11px; color:#8cdcff; letter-spacing:.6px; }
.command-icon-btn {
  appearance:none;
  width:38px;
  height:38px;
  padding:0;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border:1px solid #5584ab;
  border-radius:10px;
  background:linear-gradient(160deg,#0f2842 0%,#0a1e34 60%,#081629 100%);
}
.command-icon-btn img {
  width:24px;
  height:24px;
  object-fit:contain;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.command-grid {
  padding:10px;
  display:flex;
  gap:8px;
  align-items:center;
  overflow-x:auto;
  overflow-y:hidden;
}
.palette-card {
  appearance:none;
  border:1px solid #5584ab;
  width:88px;
  height:88px;
  min-width:88px;
  border-radius:12px;
  background:linear-gradient(150deg,#0f2842 0%,#0a1e34 58%,#081629 100%);
  box-shadow:0 7px 14px #00000066;
  cursor:grab;
  display:flex;
  align-items:center;
  justify-content:center;
  position:relative;
}
.palette-card:hover {
  border-color:#8de7ff;
  box-shadow:0 0 0 1px #95e6ff44 inset, 0 8px 18px #0000007a;
}
.palette-card.active {
  border-color:#8de7ff;
  box-shadow:0 0 0 1px #95e6ff77 inset, 0 0 20px #57dfff4f;
}
.palette-card:active { cursor:grabbing; }
.palette-sprite {
  width:56px;
  height:56px;
  object-fit:contain;
  opacity:.95;
  filter:none;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.palette-card .hotkey {
  font-size:10px;
  color:#8cdcff;
  position:absolute;
  right:6px;
  bottom:4px;
  font-family:'Geist Mono', monospace;
  letter-spacing:.5px;
}
.world-wrap.drop-armed { outline:2px dashed #8de7ff; outline-offset:-6px; }
.placement-layer { pointer-events:none; }
.placement-ghost { opacity:.45; border-style:dashed; }
.placement-ghost.invalid .building-sprite { filter:hue-rotate(-42deg) saturate(1.25) brightness(1.05); }
.building-sprite {
  width:var(--sprite-w,100%);
  height:var(--sprite-h,100%);
  object-fit:contain;
  display:block;
  pointer-events:none;
  filter:none;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
}
.build-card {
  border:1px solid #3f6283;
  border-radius:10px;
  padding:8px;
  background:linear-gradient(150deg,#0e223a 0%,#091a2f 58%,#081629 100%);
  box-shadow:0 9px 16px #00000066;
}
.build-card strong { display:block; font-size:12px; margin-bottom:5px; color:#caf4ff; }
.build-card small { color:var(--muted); font-size:11px; display:block; }
.kv { font-size:12px; color:var(--muted); margin-bottom:7px; }
.kv strong { color:var(--corpus-ice); }
.entity {
  position:absolute;
  transform-style:preserve-3d;
  filter:none;
  pointer-events:auto;
}
.iso-core {
  position:relative;
  border:none;
  background:none;
  overflow:visible;
}
.iso-core:before {
  content:none;
  position:absolute;
  inset:-1px;
  background:linear-gradient(130deg,#d9fbff2f 0%,transparent 28%,transparent 65%,#58deff2f 100%);
  pointer-events:none;
}
.iso-top,
.iso-side {
  display:none;
}
.iso-top {
  left:0;
  right:0;
}
.iso-side {
  top:0;
  right:0;
}
.base { width:var(--footprint-w,176px); height:var(--footprint-h,132px); }
.base .iso-core { width:100%; height:100%; border-radius:0; padding:0; }
.movable { cursor:move; }
.base .name { font-size:12px; font-weight:700; color:#baf5ff; }
.base .repo { margin-top:6px; font-size:11px; color:#9eb5cb; font-family:'Geist Mono', monospace; }
.base .conduit {
  margin-top:12px;
  height:8px;
  border-radius:999px;
  border:1px solid #7de7ff7a;
  background:linear-gradient(90deg,#40d8ff,#8fffff,#4ec9ff);
  box-shadow:0 0 10px #62deff77;
}
.building { width:var(--footprint-w,132px); min-height:var(--footprint-h,88px); }
.building .iso-core { border-radius:0; padding:0; min-height:var(--footprint-h,88px); cursor:pointer; }
.building .title { font-size:12px; font-weight:600; margin-bottom:7px; }
.meta { display:flex; justify-content:space-between; align-items:center; font-size:11px; color:var(--muted); margin-bottom:7px; }
.badge { font-size:10px; border:1px solid #5d8cae; border-radius:999px; padding:2px 6px; }
.port-chip {
  position:absolute;
  left:8px;
  top:8px;
  z-index:5;
  border:1px solid #4d7da0;
  border-radius:999px;
  padding:2px 7px;
  font-size:10px;
  line-height:1.1;
  color:#c9edff;
  background:#07172bcc;
  font-family:'Geist Mono', monospace;
}
.progress { height:8px; border-radius:999px; border:1px solid #4f7693; overflow:hidden; background:#08101d; }
.bar { height:100%; background:linear-gradient(90deg,#58ffe4,#66cbff); }
.pr-link { display:block; margin-top:8px; font-size:11px; color:#a7efff; text-decoration:none; border:1px solid #4f8cae; border-radius:7px; padding:6px; }
.ghost { opacity:.86; border-style:dashed; }
.draft-ghost { opacity:.46; border-style:dashed; }
.draft-ghost .iso-core { border-color:#86dcffa2; }
.is-half-transparent { opacity:.5; }
.is-failed { filter:saturate(0.7) hue-rotate(-18deg) brightness(0.92); }
.unit {
  position:absolute;
  width:32px; height:32px;
  background:url('/rts-sprites/unit-cephalon-test.png?v=20260212b') center/contain no-repeat;
  filter:none;
  cursor:pointer;
  animation:float-unit 1.8s ease-in-out infinite alternate;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.unit-model-chip {
  position:absolute;
  transform:translate(13px,-9px);
  background:#0d2035d9;
  border:1px solid #5486a8;
  border-radius:999px;
  padding:1px 6px;
  white-space:nowrap;
  font-size:9px;
  color:#a3efff;
  pointer-events:none;
}
.subunit {
  position:absolute;
  width:16px; height:16px;
  background:url('/rts-sprites/subunit-cephalon-test.png?v=20260212b') center/contain no-repeat;
  filter:none;
  image-rendering:pixelated;
  image-rendering:crisp-edges;
}
.camera-hint {
  position:absolute;
  left:12px;
  bottom:152px;
  pointer-events:none;
  z-index:45;
  background:#0b1a2fbd;
  border:1px solid #436f91;
  border-radius:8px;
  padding:6px 8px;
}
@keyframes float-unit { from { transform:translateY(-2px); } to { transform:translateY(2px); } }
.skill-grid { display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:6px; }
.skill { border:1px solid #416e90; border-radius:8px; padding:6px; font-size:11px; background:#0a1b2f; }
input[type="text"], input:not([type]), textarea { width:100%; margin-top:4px; }
textarea { min-height:132px; resize:vertical; font-family:Inter,system-ui,sans-serif; }
.status-dot { display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; }
.agent-list { display:flex; flex-direction:column; gap:6px; margin-top:8px; }
.agent-row {
  border:1px solid #3f6788;
  border-radius:8px;
  padding:7px 8px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  font-size:11px;
  background:#0b1a2f;
  cursor:pointer;
}
.agent-row:hover { border-color:#85dfff; }
.agent-row.active { border-color:#8de7ff; box-shadow:0 0 0 1px #95e6ff44 inset; }
.agent-meta { display:flex; align-items:center; gap:6px; min-width:0; }
.agent-name { font-family:'Geist Mono', monospace; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:180px; }
.agent-actions { display:flex; align-items:center; gap:6px; }
.agent-restart {
  border:1px solid #7f95b0;
  background:#122237;
  color:#cbe9ff;
  border-radius:6px;
  padding:2px 6px;
  font-size:10px;
}
.agent-restart:hover { border-color:#a1c6ea; }
.agent-redo {
  border:1px solid #5f9b78;
  background:#102a1f;
  color:#cfffe4;
  border-radius:6px;
  padding:2px 6px;
  font-size:10px;
}
.agent-redo:hover { border-color:#81d6a9; }
.term-wrap {
  margin-top:8px;
  border:1px solid #456c8d;
  border-radius:8px;
  background:#040b14;
  overflow:hidden;
}
.term-head {
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:6px 8px;
  border-bottom:1px solid #34556f;
  font-size:10px;
  color:var(--muted);
}
.term-actions {
  display:flex;
  align-items:center;
  gap:8px;
}
.term-copy {
  border:1px solid #7f95b0;
  background:#122237;
  color:#cbe9ff;
  border-radius:6px;
  padding:2px 6px;
  font-size:10px;
}
.term-copy:hover { border-color:#a1c6ea; }
.term-view {
  max-height:420px;
  min-height:280px;
  overflow:auto;
  padding:12px;
  font-family:'Geist Mono', monospace;
  font-size:13px;
  line-height:1.55;
  white-space:pre;
  color:#c9f5ff;
  background:#020913;
}
.cli-panel {
  border:1px solid #3b6384;
  border-radius:8px;
  background:#050d17;
  padding:8px;
}
.cli-head {
  display:flex;
  justify-content:space-between;
  font-family:'Geist Mono', monospace;
  font-size:10px;
  color:#8bdfff;
  margin-bottom:6px;
}
.cli-body {
  max-height:200px;
  overflow:auto;
  font-family:'Geist Mono', monospace;
  font-size:11px;
  line-height:1.35;
  white-space:pre;
  color:#c9f5ff;
}
.unit.live-running { filter:saturate(1.1) brightness(1.05); }
.unit.live-stale { filter:hue-rotate(-30deg) saturate(1.2); }
@media (max-width:1180px) {
  .command-grid { flex-wrap:wrap; }
  .hud { flex-direction:column; right:auto; width:min(360px, calc(100vw - 24px)); }
  .hud-right { width:100%; max-height:42vh; }
  .camera-hint { bottom:170px; }
}
@media (max-width:760px) {
  .hud {
    top:8px;
    left:8px;
    right:8px;
    width:calc(100vw - 16px);
  }
  .hud-left {
    width:100%;
    justify-content:space-between;
    flex-wrap:wrap;
  }
  .hud-right {
    width:100%;
    max-height:36vh;
  }
  .command-bar {
    left:8px;
    right:8px;
    width:auto;
    transform:none;
    bottom:8px;
  }
  .palette-card {
    width:72px;
    height:72px;
    min-width:72px;
  }
  .palette-sprite {
    width:44px;
    height:44px;
  }
  .term-view {
    min-height:180px;
    max-height:260px;
    font-size:12px;
  }
}
</style>
</head>
<body>
  <div class="layout">
    <div class="world-wrap" id="worldWrap">
      <div class="world-bg"></div>
      <div id="world" class="world"></div>
      <div id="pathLayer" class="world path-layer"></div>
      <div id="placementLayer" class="world placement-layer"></div>
    </div>
    <div class="hud">
      <div class="hud-left panel">
        <div class="command-title">BUILD TRACE 2</div>
        <button id="cancelPlacementBtn" class="command-icon-btn" title="Cancel placement (Esc)" aria-label="Cancel placement (Escape)">
          <img src="/rts-sprites/cancel-button.svg?v=20260212" alt="" aria-hidden="true" />
        </button>
        <button id="deleteSelectedBtn" class="command-icon-btn" title="Delete selected (Delete)" aria-label="Delete selected (Delete)">
          <img src="/rts-sprites/delete-button.svg?v=20260212" alt="" aria-hidden="true" />
        </button>
        <a href="/" title="Classic board" aria-label="Classic board" style="color:var(--corpus-ice);text-decoration:none;font-size:14px;border:1px solid #4c7da2;border-radius:8px;padding:7px 10px;text-align:center;">[]</a>
        <div class="notice" id="placementNotice">IDLE</div>
      </div>
      <div class="hud-right">
        <div class="panel" id="livePanel">
          <h3>Live Agent TTY</h3>
          <div class="notice">Loading machine state...</div>
        </div>
        <div class="panel" id="selectionPanel">
          <h3>Selection Panel</h3>
          <div class="notice">Select base/building/unit for RTS-style intel and actions.</div>
        </div>
        <div class="panel" id="actionPanel">
          <h3>Action Console</h3>
          <div class="notice">Use build icons to place Base or Feature Forge.</div>
        </div>
      </div>
    </div>

    <section class="command-bar">
      <div class="command-grid">
        <button class="palette-card" draggable="true" data-building="base" title="Base Core (B)">
          <img class="palette-sprite" src="/rts-sprites/base-core-corpus-test.png?v=20260212b" alt="" />
          <span class="hotkey">B</span>
        </button>
        <button class="palette-card" draggable="true" data-building="feature" title="Feature Forge (F)">
          <img class="palette-sprite" src="/rts-sprites/feature-forge-corpus-test.png?v=20260212b" alt="" />
          <span class="hotkey">F</span>
        </button>
      </div>
    </section>
  </div>

<script>
const state = {
  workflows: [], runs: [],
  localRepos: [],
  placementMode: null,
  bases: [], units: [], buildings: [],
  customBases: [],
  baseDrafts: [],
  featureBuildings: [],
  runLayoutOverrides: {},
  portByPath: {},
  runtime: null,
  live: { ts:'', activeRunCount:0, pendingRunCount:0, runningAgentCount:0, activeAgents:[] },
  diag: null,
  liveStream: null,
  runSig: '',
  selected: null,
  persistTimer: null,
  camera: { x: 0, y: 0 },
  cameraDrag: { active:false, startX:0, startY:0, originX:0, originY:0 },
  draggingEntity: null,
  draggingMoved: false,
  suppressWorldClick: false,
  stream: {
    runId: null,
    agentId: null,
    targetLines: [],
    displayedLines: [],
    pollTimer: null,
    revealTimer: null,
    stepStatus: 'idle',
    loading: false
  },
  streamSelectionByRun: {},
  featureMode: false
};

const skillTrees = {
  architect: ['System Mapping','Dependency Radar','Design Sync','API Stability'],
  builder: ['Code Synthesis','Refactor Pulse','Patch Weaving','Perf Trim'],
  verifier: ['Spec Scan','Regression Sweep','Edge Probe','Release Gate'],
  orchestrator: ['Task Routing','Priority Queue','Load Balancing','Auto Recovery'],
  subagent: ['Micro-task','Orbit Assist','Retry Loop','Signal Relay']
};

function esc(s){ return (s||'').replace(/[&<>\"]/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m])); }
function baseAgentId(agentId){
  return String(agentId || '').replace(/@run:[^/]+$/, '');
}
async function json(url){
  const r = await fetch(url);
  const data = await r.json();
  if (!r.ok) throw new Error(data?.error || `request_failed:${r.status}`);
  return data;
}
async function postJson(url, body){
  const r = await fetch(url, {
    method:'POST',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(body)
  });
  const data = await r.json();
  if (!r.ok || data?.ok === false) throw new Error(data?.error || data?.next || `request_failed:${r.status}`);
  return data;
}

function snapshotPersistableState(){
  return {
    customBases: state.customBases || [],
    baseDrafts: state.baseDrafts || [],
    featureBuildings: state.featureBuildings || [],
    runLayoutOverrides: state.runLayoutOverrides || {},
    portByPath: state.portByPath || {},
    selected: state.selected || null,
    camera: state.camera || { x:0, y:0 }
  };
}

function queuePersist(){
  if (state.persistTimer) clearTimeout(state.persistTimer);
  state.persistTimer = setTimeout(async () => {
    const payload = snapshotPersistableState();
    try {
      await postJson('/api/rts/state', { state: payload });
    } catch {}
  }, 250);
}

async function persistNow(){
  if (state.persistTimer) {
    clearTimeout(state.persistTimer);
    state.persistTimer = null;
  }
  const payload = snapshotPersistableState();
  try {
    await postJson('/api/rts/state', { state: payload });
  } catch {}
}

function resolveDraggedEntityPosition(drag){
  if (!drag) return null;
  if (drag.type === 'base') {
    const b = (state.customBases || []).find((x) => x.id === drag.id);
    return b ? { x:Number(b.x)||0, y:Number(b.y)||0 } : null;
  }
  if (drag.type === 'feature') {
    const f = (state.featureBuildings || []).find((x) => x.id === drag.id) || (state.buildings || []).find((x) => x.id === drag.id);
    return f ? { x:Number(f.x)||0, y:Number(f.y)||0 } : null;
  }
  if (drag.type === 'run') {
    const p = state.runLayoutOverrides?.[drag.runId || drag.id];
    if (p) return { x:Number(p.x)||0, y:Number(p.y)||0 };
    const b = (state.buildings || []).find((x) => x.id === drag.id);
    return b ? { x:Number(b.x)||0, y:Number(b.y)||0 } : null;
  }
  return null;
}

async function persistDraggedEntityPosition(drag){
  const pos = resolveDraggedEntityPosition(drag);
  if (!pos) return;
  const entityType = drag.type === 'base' ? 'base' : (drag.type === 'feature' ? 'feature' : 'run');
  await postJson('/api/rts/layout/position', {
    entityType,
    entityId: drag.id,
    runId: drag.runId || null,
    repoPath: drag.repoPath || null,
    worktreePath: drag.worktreePath || null,
    x: pos.x,
    y: pos.y
  });
}

async function hydratePersistedState(){
  let persisted = null;
  try {
    const r = await json('/api/rts/state');
    persisted = r?.state || null;
  } catch {}
  if (!persisted || typeof persisted !== 'object') return;
  if (Array.isArray(persisted.customBases)) {
    const byRepo = new Map();
    for (const raw of persisted.customBases) {
      const b = raw && typeof raw === 'object' ? raw : {};
      const repo = baseRepoKey(String(b.repo || ''));
      const id = String(b.id || `base-${repo}`);
      byRepo.set(repo, {
        ...b,
        id,
        repo,
        source: 'custom',
        x: Number(b.x || 0),
        y: Number(b.y || 0),
      });
    }
    state.customBases = Array.from(byRepo.values());
  }
  if (Array.isArray(persisted.baseDrafts)) state.baseDrafts = persisted.baseDrafts;
  if (Array.isArray(persisted.featureBuildings)) {
    const seen = new Set();
    state.featureBuildings = persisted.featureBuildings
      .map(normalizeFeatureDraft)
      .filter((fb) => {
      const runKey = fb?.runId ? `run:${fb.runId}` : "";
      const key = runKey || `draft:${fb?.id || ""}:${fb?.repo || ""}:${fb?.x || 0}:${fb?.y || 0}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }
  if (persisted.runLayoutOverrides && typeof persisted.runLayoutOverrides === 'object') state.runLayoutOverrides = persisted.runLayoutOverrides;
  if (persisted.portByPath && typeof persisted.portByPath === 'object') {
    state.portByPath = persisted.portByPath;
  }
  if (persisted.camera && typeof persisted.camera === 'object') {
    state.camera = {
      x: Number(persisted.camera.x) || 0,
      y: Number(persisted.camera.y) || 0
    };
  }
  if (!state.featureBuildings.length && Array.isArray(persisted.setupDrafts)) {
    state.featureBuildings = persisted.setupDrafts
      .map((d) => normalizeFeatureDraft({ ...d, phase: 'draft' }));
  }
  // unified view: no persisted workflow filter
  if (persisted.selected && typeof persisted.selected === 'object') {
    if (persisted.selected.type === 'featureDraft' && persisted.selected.data) {
      state.selected = { type:'building', data:{ ...persisted.selected.data, kind:'feature', phase:'draft' } };
    } else {
      state.selected = persisted.selected;
    }
  }
}
function parseContext(run){ try { return JSON.parse(run.context || '{}'); } catch { return {}; } }
function extractPrUrl(run){
  const candidates = [run.task, run.context, ...(run.steps||[]).map(s=>s.output||'')].join('\n');
  const m = candidates.match(/https?:\/\/[^\s)]+\/pull\/[0-9]+/i);
  return m ? m[0] : null;
}
function runProgress(run){
  const steps = run.steps || [];
  if (!steps.length) return 0;
  const done = steps.filter(s => s.status === 'done' || s.status === 'skipped').length;
  return Math.round((done / steps.length) * 100);
}
function getRepo(run){
  const ctx = parseContext(run);
  // Prefer original base repo path so run/feature buildings stay attached
  // to the user-placed movable base instead of worktree-derived auto bases.
  const raw = ctx.baseRepoPath || ctx.repoPath || ctx.repo || ctx.repository || ctx.worktreePath || '';
  return normalizePathKey(raw).replace(/-feature-[^/]+$/i, '');
}
function getWorktreeDefault(repo){
  const clean = repo.split('/').pop() || 'repo';
  return `../${clean}-feature-${Date.now().toString().slice(-4)}`;
}
function normalizePathKey(raw){
  return String(raw || '').trim().replace(/\\/g, '/').replace(/\/+$/, '');
}
function isAbsolutePathKey(key){
  return key.startsWith('/') || /^[A-Za-z]:\//.test(key);
}
function baseRepoKey(pathValue){
  let key = normalizePathKey(pathValue || '');
  if (key === 'workspace-repo' && state.runtime?.cwd) key = normalizePathKey(state.runtime.cwd);
  if (!isAbsolutePathKey(key) && state.runtime?.cwd) key = absolutizePath(key, state.runtime.cwd);
  if (!key) return 'workspace-repo';
  return key.replace(/-feature-[^/]+$/i, '') || 'workspace-repo';
}
function absolutizePath(pathValue, repoPath){
  const key = normalizePathKey(pathValue);
  if (!key) return '';
  if (isAbsolutePathKey(key)) return key;
  let base = normalizePathKey(repoPath);
  if (!isAbsolutePathKey(base) && state.runtime?.cwd) base = normalizePathKey(state.runtime.cwd);
  if (!base) return key;
  const stack = base.split('/');
  for (const part of key.split('/')) {
    if (!part || part === '.') continue;
    if (part === '..') {
      if (stack.length > 1) stack.pop();
      continue;
    }
    stack.push(part);
  }
  return stack.join('/');
}
function inferPortFromPath(pathValue){
  const key = normalizePathKey(pathValue);
  if (!key) return null;
  if (/\/antfarm$/.test(key)) return 3333;
  const featureMatch = key.match(/antfarm-feature-(\d+)/i);
  if (featureMatch) {
    const n = Number(featureMatch[1] || 0);
    if (Number.isFinite(n)) return 3400 + (n % 400);
  }
  return null;
}
function getPortForPath(pathValue){
  const key = normalizePathKey(pathValue);
  if (!key) return null;
  const mapped = Number(state.portByPath?.[key]);
  if (Number.isFinite(mapped) && mapped > 0 && mapped < 65536) return mapped;
  return inferPortFromPath(key);
}
function setPortForPath(pathValue, portValue){
  const key = normalizePathKey(pathValue);
  const port = Number(portValue);
  if (!key) return;
  if (!Number.isFinite(port) || port < 1 || port > 65535) return;
  state.portByPath = {
    ...(state.portByPath || {}),
    [key]: Math.floor(port),
  };
}
function pathLabel(pathValue){
  const key = normalizePathKey(pathValue);
  if (!key) return 'base';
  const featureMatch = key.match(/antfarm-feature-(\d+)/i);
  if (featureMatch) return `feature-${featureMatch[1]}`;
  if (/\/antfarm$/.test(key)) return 'master';
  const parts = key.split('/');
  return parts[parts.length - 1] || 'base';
}
function runtimeLink(portValue){
  const port = Number(portValue);
  if (!Number.isFinite(port) || port < 1 || port > 65535) return '<span class="badge">unassigned</span>';
  const host = `100.115.134.49:${Math.floor(port)}`;
  const href = `http://${host}`;
  return `<a class="pr-link" href="${href}" target="_blank" rel="noopener noreferrer">${host}</a>`;
}
function factionFromWorkflow(id){ return (id || 'neutral').split(/[^a-z0-9]+/i)[0] || 'neutral'; }
function inferUnitModel(agentId, run){
  // TODO(server): expose per-agent runtime model metadata from run execution payload.
  const ctx = parseContext(run);
  const modelMap = ctx.agentModels || ctx.modelsByAgent || ctx.models;
  if (modelMap && typeof modelMap === 'object' && modelMap[agentId]) return String(modelMap[agentId]);
  if (ctx.model && typeof ctx.model === 'string') return ctx.model;
  return 'unknown';
}

const GRID_SIZE = 22;
const FOOTPRINTS = {
  base: { cols: 8, rows: 6, spriteW: 206, spriteH: 132 },
  feature: { cols: 6, rows: 4, spriteW: 186, spriteH: 98 },
  run: { cols: 6, rows: 4, spriteW: 186, spriteH: 98 }
};

function buildingFootprint(kind){
  const key = (kind === 'base' || kind === 'feature' || kind === 'run') ? kind : 'run';
  const fp = FOOTPRINTS[key];
  return {
    cols: fp.cols,
    rows: fp.rows,
    w: fp.cols * GRID_SIZE,
    h: fp.rows * GRID_SIZE,
    spriteW: fp.spriteW,
    spriteH: fp.spriteH
  };
}

function centerPointFor(kind, x, y){
  const fp = buildingFootprint(kind);
  return { x: Number(x || 0) + (fp.w / 2), y: Number(y || 0) + (fp.h / 2) };
}

function worldDepth(y, bias = 100000){
  return Math.max(1, bias + Math.floor(Number(y) || 0));
}

function getLiveAgentEntry(runId, agentId){
  const list = state.live?.activeAgents || [];
  return list.find((a) => a.runId === runId && a.agentId === agentId) || null;
}

function runTargetCenterMap(){
  const targets = new Map();
  (state.buildings || []).forEach((b) => {
    const rid = b.run?.id || b.runId || (b.kind === 'run' ? b.id : '');
    if (!rid) return;
    const centerRaw = centerPointFor(b.kind === 'feature' ? 'feature' : 'run', b.x, b.y);
    const center = { x: centerRaw.x, y: centerRaw.y, kind: b.kind };
    const current = targets.get(rid);
    if (!current || (current.kind === 'run' && b.kind === 'feature')) targets.set(rid, center);
  });
  return targets;
}

function activeRunAgentMap(){
  const m = new Map();
  const list = Array.isArray(state.live?.activeAgents) ? state.live.activeAgents : [];
  list.forEach((entry) => {
    if (!entry?.runId || !entry?.agentId) return;
    if (!m.has(entry.runId)) m.set(entry.runId, entry.agentId);
  });
  return m;
}

function renderLiveConsole(){
  const panel = document.getElementById('livePanel');
  if (!panel) return;
  const live = state.live || {};
  const diag = state.diag || {};
  const agents = Array.isArray(live.activeAgents) ? live.activeAgents : [];
  const stamp = live.ts ? new Date(live.ts).toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' }) : '--:--:--';
  const cronCount = Number(diag?.cron?.matchingCount || 0);
  const workerTotal = Number(live?.workerTotal || cronCount || 0);
  const blocked = diag?.likelyBlockedReason ? `WARN ${diag.likelyBlockedReason}` : '';
  const runtimeLine = state.runtime?.cwd ? `${state.runtime.cwd} @ :${state.runtime.port || 3333}` : '';
  const lines = agents.length
    ? agents.slice(0, 120).map((a) => {
      const age = typeof a.ageSec === 'number' ? String(a.ageSec).padStart(3, ' ') : ' --';
      const status = a.stale ? 'STALE' : 'RUN';
      const agentShort = String(a.agentId || '').split('/').pop() || a.agentId || 'unknown';
      const runShort = String(a.runId || '').slice(0, 8);
      return `${status} ${age}s  ${runShort}  ${agentShort}  ${a.stepId || 'step'}`;
    }).join('\n')
    : 'IDLE  no active agents';

  panel.innerHTML = `
    <h3>Live Agent TTY</h3>
    <div class="cli-panel">
      <div class="cli-head">
        <span>RUN ${live.activeRunCount || 0} | WAIT ${live.pendingRunCount || 0} | AGENT ${live.runningAgentCount || 0} | WORKERS ${workerTotal}</span>
        <span>${esc(stamp)}</span>
      </div>
      <div class="cli-body">${esc(lines)}</div>
    </div>
    <div class="notice" style="margin-top:6px">Source: Antfarm DB step state on this machine. ${esc(blocked)}</div>
    ${runtimeLine ? `<div class="notice" style="margin-top:4px">Serving: ${esc(runtimeLine)}</div>` : ''}
  `;
}

function runsSignature(runs){
  return (runs || [])
    .map((r) => `${r.id}:${r.status}:${r.updated_at || ''}`)
    .sort()
    .join('|');
}

async function boot(){
  await hydratePersistedState();
  state.workflows = await json('/api/workflows');
  try { state.localRepos = await json('/api/local-repos'); } catch { state.localRepos = []; }
  try { state.runtime = (await json('/api/rts/runtime')).runtime || null; } catch { state.runtime = null; }
  await refreshRuntimeState(true);
  rebuildScene();
  renderLiveConsole();
  startLiveStream();
  queuePersist();
}

async function refreshRuntimeState(throwOnError = false){
  try {
    const [runs, liveRes, diagRes] = await Promise.all([
      json('/api/runs'),
      json('/api/rts/live'),
      json('/api/rts/diag?workflow=feature-dev')
    ]);
    const nextSig = runsSignature(runs);
    const runsChanged = nextSig !== state.runSig;
    state.runs = runs;
    state.runSig = nextSig;
    state.live = (liveRes && liveRes.live) ? liveRes.live : state.live;
    state.diag = (diagRes && diagRes.diag) ? diagRes.diag : state.diag;
    return runsChanged;
  } catch (err) {
    if (throwOnError) throw err;
    return false;
  }
}

function startLiveStream(){
  if (state.liveStream) {
    try { state.liveStream.close(); } catch {}
    state.liveStream = null;
  }
  try {
    const es = new EventSource('/api/rts/live/stream');
    es.addEventListener('live', (evt) => {
      try {
        const payload = JSON.parse(evt.data || '{}');
        state.live = payload || state.live;
        if (Number(state.live?.runningAgentCount || 0) > 0) {
          ensureMotionLoop();
          renderUnitsLiveState();
        } else {
          renderUnitsLiveState();
        }
        renderLiveConsole();
      } catch {}
    });
    es.onerror = () => {
      try { es.close(); } catch {}
      state.liveStream = null;
    };
    state.liveStream = es;
  } catch {
    state.liveStream = null;
  }
}

function rebuildScene(){
  updateCameraVisuals();
  const customByRepo = new Map();
  (state.customBases || []).forEach((cb) => {
    if (!cb?.repo) return;
    const repoKey = baseRepoKey(cb.repo);
    customByRepo.set(repoKey, { ...cb, repo: repoKey });
  });

  const runsByRepo = new Map();
  (state.runs || []).forEach((run) => {
    const rawRepo = normalizePathKey(getRepo(run));
    if (!rawRepo) return;
    const repo = baseRepoKey(rawRepo);
    if (!runsByRepo.has(repo)) runsByRepo.set(repo, []);
    runsByRepo.get(repo).push(run);
  });

  const mergedBases = [];
  const usedCustomBaseIds = new Set();
  let autoIndex = 0;
  runsByRepo.forEach((runs, repo) => {
    const existingCustom = customByRepo.get(repo);
    if (existingCustom) {
      const resolvedPort = Number(existingCustom.port) || getPortForPath(existingCustom.repo) || 3333;
      if (existingCustom.repo) setPortForPath(existingCustom.repo, resolvedPort);
      mergedBases.push({ ...existingCustom, runs, source:'custom', port: resolvedPort, portLabel: pathLabel(existingCustom.repo) });
      usedCustomBaseIds.add(existingCustom.id);
      return;
    }
    const resolvedPort = getPortForPath(repo) || 3333;
    setPortForPath(repo, resolvedPort);
    mergedBases.push({
      id:`base-run-${autoIndex}`,
      x: 90 + (autoIndex%3)*320,
      y: 80 + Math.floor(autoIndex/3)*220,
      repo,
      runs,
      source:'run',
      port: resolvedPort,
      portLabel: pathLabel(repo)
    });
    autoIndex += 1;
  });

  (state.customBases || []).forEach((cb) => {
    if (usedCustomBaseIds.has(cb.id)) return;
    const repoKey = baseRepoKey(cb.repo);
    const resolvedPort = Number(cb.port) || getPortForPath(repoKey) || 3333;
    if (repoKey) setPortForPath(repoKey, resolvedPort);
    mergedBases.push({ ...cb, repo: repoKey, runs: cb.runs || [], source:'custom', port: resolvedPort, portLabel: pathLabel(repoKey) });
  });

  const buildings = [];
  const units = [];
  const runBaseCenters = new Map();
  const baseFp = buildingFootprint('base');
  const runFp = buildingFootprint('run');
  const persistedFeatureByRunId = new Map(
    (state.featureBuildings || [])
      .filter((f) => f?.runId)
      .map((f) => [f.runId, f])
  );
  const linkedFeatureRunIds = new Set([...persistedFeatureByRunId.keys()]);
  const runDefaultLayout = new Map();
  mergedBases.forEach(base => {
    (base.runs || []).forEach((run, ri) => {
      const runCtx = parseContext(run);
      const runWorktreePath = String(runCtx.worktreePath || '');
      const runRepoPath = baseRepoKey(String(runCtx.baseRepoPath || runCtx.repoPath || getRepo(run) || ''));
      const basePort = Number(base.port) || getPortForPath(base.repo || '') || 3333;
      const runPort = getPortForPath(runWorktreePath) || getPortForPath(runRepoPath) || (basePort + 1);
      runBaseCenters.set(run.id, centerPointFor('base', base.x, base.y));
      const defaultX = Number(base.x + GRID_SIZE + (ri%2)*(runFp.w + GRID_SIZE));
      const defaultY = Number(base.y + baseFp.h + GRID_SIZE + Math.floor(ri/2)*(runFp.h + GRID_SIZE));
      runDefaultLayout.set(run.id, { x: defaultX, y: defaultY });
      if (!linkedFeatureRunIds.has(run.id)) {
        const override = state.runLayoutOverrides?.[run.id];
        buildings.push({
          id: run.id,
          kind: 'run',
          run,
          x: Number(override?.x ?? defaultX),
          y: Number(override?.y ?? defaultY),
          progress: runProgress(run),
          prUrl: extractPrUrl(run),
          repo: runRepoPath,
          worktreePath: runWorktreePath,
          port: runPort,
          portLabel: pathLabel(runWorktreePath || runRepoPath)
        });
      }

      const faction = factionFromWorkflow(run.workflow_id);
      const agents = [...new Set((run.steps||[]).map(s => s.agent_id).filter(Boolean))];
      agents.forEach((agent, ai) => {
        units.push({
          id: `${run.id}-u-${ai}`,
          runId: run.id,
          label: agent.split('/').pop(),
          full: agent,
          faction,
          model: inferUnitModel(agent, run),
          x: base.x + baseFp.w + 26 + (ai*24),
          y: base.y + 10 + (ri*24),
          homeX: base.x + baseFp.w + 26 + (ai*24),
          homeY: base.y + 10 + (ri*24),
          baseCenterX: base.x + (baseFp.w / 2),
          baseCenterY: base.y + (baseFp.h / 2),
          subagents: 2 + (ai % 3)
        });
      });
    });
  });

  (state.featureBuildings || []).forEach((fb) => {
    const repoPath = baseRepoKey(String(fb.repo || ''));
    const worktreePathRaw = String(fb.worktreePath || '');
    const worktreePath = absolutizePath(worktreePathRaw, repoPath);
    const run = fb.runId
      ? (state.runs || []).find(r => r.id === fb.runId)
      : (state.runs || []).find((r) => {
          const ctx = parseContext(r);
          const runWt = absolutizePath(String(ctx.worktreePath || ''), String(ctx.baseRepoPath || ctx.repoPath || repoPath));
          return !!runWt && !!worktreePath && runWt === worktreePath;
        });
    const fallbackPort = getPortForPath(worktreePath || '') || getPortForPath(repoPath || '') || 3334;
    const port = Number(fb.port) || fallbackPort;
    if (worktreePath) setPortForPath(worktreePath, port);
    buildings.push({
      ...fb,
      kind: 'feature',
      run,
      runId: run?.id || fb.runId || null,
      progress: run ? runProgress(run) : 0,
      prUrl: run ? extractPrUrl(run) : null,
      phase: run ? (run.status || 'running') : 'draft',
      port,
      worktreePath: worktreePath || worktreePathRaw,
      portLabel: pathLabel(worktreePath || repoPath || '')
    });
  });

  state.bases = mergedBases;
  state.buildings = buildings;
  const runTargets = runTargetCenterMap();
  const activeMap = activeRunAgentMap();
  const nowSec = Date.now() / 1000;
  state.units = units.map((u, idx) => {
    const target = runTargets.get(u.runId);
    const activeAgent = activeMap.get(u.runId);
    const isActive = !!target && activeAgent === u.full;
    if (!isActive || !target) return u;
    const homeX = Number(u.homeX ?? u.x);
    const homeY = Number(u.homeY ?? u.y);
    const tx = Number(target.x);
    const ty = Number(target.y);
    const cycle = 0.8 + (((u.runId.charCodeAt(0) || 7) + idx) % 5) * 0.07;
    const phase = nowSec * cycle;
    const pingPong = (Math.sin(phase) + 1) / 2;
    const x = homeX + (tx - homeX) * pingPong;
    const y = homeY + (ty - homeY) * pingPong;
    return { ...u, x, y, moving: true };
  });

  if (state.selected?.type === 'building') {
    const fresh = state.buildings.find(b => b.id === state.selected.data.id);
    if (fresh) state.selected = { type:'building', data:fresh };
    else state.selected = null;
  } else if (state.selected?.type === 'unit') {
    const fresh = state.units.find(u => u.runId === state.selected.data.runId && u.full === state.selected.data.full);
    if (fresh) state.selected = { type:'unit', data:fresh };
    else state.selected = null;
  } else if (state.selected?.type === 'baseDraft') {
    const fresh = (state.baseDrafts || []).find(d => d.id === state.selected.data.id);
    if (fresh) state.selected = { type:'baseDraft', data:fresh };
    else state.selected = null;
  } else if (state.selected?.type === 'base') {
    const fresh = state.bases.find(b => b.id === state.selected.data.id);
    if (fresh) state.selected = { type:'base', data:fresh };
    else state.selected = null;
  }

  renderWorld();
  if (Number(state.live?.runningAgentCount || 0) > 0) ensureMotionLoop();
  if (state.selected) renderSelection();
  if (state.selected?.type === 'building' && state.selected.data?.kind === 'feature' && !isEditingActionPanel()) {
    renderRunSetupPanel(state.selected.data.id);
  }
}

function renderUnitsMotionFrame(){
  const runTargets = runTargetCenterMap();
  const activeMap = activeRunAgentMap();
  const nowSec = Date.now() / 1000;

  state.units.forEach((u, idx) => {
    const node = document.querySelector(`.unit[data-run-id="${CSS.escape(u.runId)}"][data-agent-id="${CSS.escape(u.full)}"]`);
    if (!node) return;
    const target = runTargets.get(u.runId);
    const activeAgent = activeMap.get(u.runId);
    const isActive = !!target && activeAgent === u.full;
    const homeX = Number(u.homeX ?? u.x);
    const homeY = Number(u.homeY ?? u.y);
    let ux = Number(u.x);
    let uy = Number(u.y);
    if (isActive && target) {
      const tx = Number(target.x);
      const ty = Number(target.y);
      const cycle = 0.8 + (((u.runId.charCodeAt(0) || 7) + idx) % 5) * 0.07;
      const phase = nowSec * cycle;
      const pingPong = (Math.sin(phase) + 1) / 2;
      ux = homeX + (tx - homeX) * pingPong;
      uy = homeY + (ty - homeY) * pingPong;
    }
    const p = worldToScreen(ux, uy);
    node.style.left = `${p.x}px`;
    node.style.top = `${p.y}px`;
    node.style.zIndex = String(worldDepth(uy, 2000));
    node.classList.toggle('moving', isActive);
  });
}

function ensureMotionLoop(){
  if (state.motionTimer) return;
  state.motionTimer = setInterval(() => {
    if (Number(state.live?.runningAgentCount || 0) <= 0) {
      clearInterval(state.motionTimer);
      state.motionTimer = null;
      return;
    }
    renderUnitsMotionFrame();
  }, 120);
}

function setPlacement(mode){
  state.placementMode = mode;
  const notice = document.getElementById('placementNotice');
  if (!mode) notice.textContent = 'IDLE';
  else if (mode === 'base') notice.textContent = 'BASE';
  else notice.textContent = 'FORGE';
  document.querySelectorAll('.palette-card[data-building]').forEach((card) => {
    card.classList.toggle('active', card.getAttribute('data-building') === mode);
  });
  if (!mode) hidePlacementGhost();
}

function placeBaseAt(x,y){
  const draft = {
    id:`clone-draft-${Date.now()}`,
    x,y,
    repoUrl:'',
    targetPath:'',
    existingRepoPath:'',
    port: 3333,
    label:'New Base',
    committed:false
  };
  state.baseDrafts.push(draft);
  state.selected = { type:'baseDraft', data:draft };
  queuePersist();
  rebuildScene();
  renderSelection();
  renderBaseCloneForm(draft);
}

function nearBase(x,y){
  return state.bases.find((b) => {
    const center = centerPointFor('base', b.x, b.y);
    return Math.hypot(center.x - x, center.y - y) < 240;
  }) || null;
}

function placeFeatureAt(x,y){
  const center = centerPointFor('feature', x, y);
  const base = nearBase(center.x, center.y);
  if (!base) {
    alert('Feature Request structures must be placed near a Base.');
    return;
  }
  const featureBuilding = {
    id: `feature-${Date.now()}`,
    kind:'feature',
    phase:'draft',
    committed:false,
    runId: null,
    x, y,
    repo: base.repo || 'unlinked-repo',
    worktreePath: getWorktreeDefault(base.repo || 'repo'),
    port: (Number(base.port) || getPortForPath(base.repo || '') || 3333) + 1,
    prompt: ''
  };
  state.featureBuildings.push(featureBuilding);
  void postJson('/api/rts/layout/position', {
    entityType: 'feature',
    entityId: featureBuilding.id,
    runId: null,
    repoPath: featureBuilding.repo || null,
    worktreePath: featureBuilding.worktreePath || null,
    x: featureBuilding.x,
    y: featureBuilding.y,
    allowCreate: true
  }).catch(() => {});
  state.selected = { type:'building', data:featureBuilding };
  queuePersist();
  rebuildScene();
  renderSelection();
  renderRunSetupPanel(featureBuilding.id);
}

function structureMarkup(kind){
  if (kind === 'base') {
    return `<img class="building-sprite" src="/rts-sprites/base-core-corpus-test.png?v=20260212b" alt="" />`;
  }
  if (kind === 'feature') {
    return `<img class="building-sprite" src="/rts-sprites/feature-forge-corpus-test.png?v=20260212b" alt="" />`;
  }
  return `<img class="building-sprite" src="/rts-sprites/feature-forge-corpus-test.png?v=20260212b" alt="" />`;
}

function snapPlacement(kind, worldX, worldY){
  const { w, h } = buildingFootprint(kind);
  return {
    x: Math.round((worldX - (w / 2)) / GRID_SIZE) * GRID_SIZE,
    y: Math.round((worldY - (h / 2)) / GRID_SIZE) * GRID_SIZE
  };
}

function hidePlacementGhost(){
  placementLayerEl.innerHTML = '';
}

function setFeatureMode(active){
  state.featureMode = !!active;
  const layout = document.querySelector('.layout');
  if (!layout) return;
  layout.classList.toggle('feature-mode', state.featureMode);
}

function worldToScreen(x, y){
  return { x: x - state.camera.x, y: y - state.camera.y };
}

function screenToWorld(clientX, clientY){
  const rect = worldEl.getBoundingClientRect();
  const sx = clientX - rect.left;
  const sy = clientY - rect.top;
  return { sx, sy, x: sx + state.camera.x, y: sy + state.camera.y };
}

function updateCameraVisuals(){
  worldWrapEl.style.setProperty('--cam-x', `${state.camera.x}px`);
  worldWrapEl.style.setProperty('--cam-y', `${state.camera.y}px`);
}

function showPlacementGhost(kind, worldX, worldY){
  if (!kind) return hidePlacementGhost();
  const point = snapPlacement(kind, worldX, worldY);
  const screen = worldToScreen(point.x, point.y);
  const center = centerPointFor(kind, point.x, point.y);
  const invalid = kind === 'feature' && !nearBase(center.x, center.y);
  const className = kind === 'base' ? 'base' : 'building';
  const fp = buildingFootprint(kind);
  placementLayerEl.innerHTML = `
    <div class="entity ${className} placement-ghost ${invalid ? 'invalid' : ''}" style="left:${screen.x}px;top:${screen.y}px;z-index:${worldDepth(point.y, 1000)};--footprint-w:${fp.w}px;--footprint-h:${fp.h}px;--sprite-w:${fp.spriteW}px;--sprite-h:${fp.spriteH}px">
      <div class="iso-core">${structureMarkup(kind)}</div>
    </div>
  `;
}

function localPointInWorld(event){
  return screenToWorld(event.clientX, event.clientY);
}

function edgeAutoPan(clientX, clientY, margin = 36, speed = 18){
  const rect = worldEl.getBoundingClientRect();
  if (!rect || rect.width <= 0 || rect.height <= 0) return false;
  let moved = false;
  if (clientX < rect.left + margin) { state.camera.x -= speed; moved = true; }
  else if (clientX > rect.right - margin) { state.camera.x += speed; moved = true; }
  if (clientY < rect.top + margin) { state.camera.y -= speed; moved = true; }
  else if (clientY > rect.bottom - margin) { state.camera.y += speed; moved = true; }
  if (moved) updateCameraVisuals();
  return moved;
}

function isEditingActionPanel(){
  const panel = document.getElementById('actionPanel');
  const active = document.activeElement;
  if (!panel || !active || !panel.contains(active)) return false;
  return ['INPUT','TEXTAREA','SELECT'].includes(active.tagName);
}

function updateCustomBasePosition(id, x, y){
  const i = state.customBases.findIndex(b => b.id === id);
  if (i < 0) return;
  state.customBases[i] = { ...state.customBases[i], x, y };
}

function removeBaseDraftById(id){
  state.baseDrafts = (state.baseDrafts || []).filter(d => d.id !== id);
}

function updateFeaturePosition(id, x, y){
  const i = state.featureBuildings.findIndex(b => b.id === id);
  if (i >= 0) {
    state.featureBuildings[i] = { ...state.featureBuildings[i], x, y };
    return;
  }
  const b = (state.buildings || []).find((it) => it.id === id && it.kind === 'feature');
  const runId = b?.runId || b?.run?.id || '';
  if (runId) updateRunBuildingPosition(runId, x, y);
}

function updateRunBuildingPosition(id, x, y){
  state.runLayoutOverrides = {
    ...(state.runLayoutOverrides || {}),
    [id]: { x, y }
  };
}

function updateBaseDraftPosition(id, x, y){
  const i = state.baseDrafts.findIndex(d => d.id === id);
  if (i < 0) return;
  state.baseDrafts[i] = { ...state.baseDrafts[i], x, y };
}

function cancelActiveFeatureDraft(){
  const selected = state.selected;
  if (selected?.type !== 'building' || selected?.data?.kind !== 'feature') return false;
  if (selected.data.committed || selected.data.runId) return false;
  state.featureBuildings = (state.featureBuildings || []).filter((b) => b.id !== selected.data.id);
  state.selected = null;
  queuePersist();
  rebuildScene();
  renderSelection();
  renderRunSetupPanel(null);
  return true;
}

async function deleteSelectedStructure(){
  const s = state.selected;
  if (!s) return;
  if (s.type === 'base' && s.data?.source === 'custom') {
    state.customBases = state.customBases.filter(b => b.id !== s.data.id);
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
    return;
  }
  if (s.type === 'baseDraft') {
    removeBaseDraftById(s.data.id);
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
    return;
  }
  if (s.type === 'building' && s.data?.kind === 'feature') {
    if (s.data?.runId) {
      try {
        await postJson('/api/rts/building/delete', { runId: s.data.runId });
        state.runs = await json('/api/runs');
      } catch (err) {
        alert(`Delete failed: ${err.message || err}`);
        return;
      }
      if (state.runLayoutOverrides && typeof state.runLayoutOverrides === 'object') {
        delete state.runLayoutOverrides[s.data.runId];
      }
    }
    state.featureBuildings = state.featureBuildings.filter(b => b.id !== s.data.id);
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
    return;
  }
  if (s.type === 'building' && s.data?.kind === 'run') {
    try {
      await postJson('/api/rts/building/delete', { runId: s.data.id });
      state.runs = await json('/api/runs');
    } catch (err) {
      alert(`Delete failed: ${err.message || err}`);
      return;
    }
    state.featureBuildings = (state.featureBuildings || []).filter((b) => b.runId !== s.data.id);
    if (state.runLayoutOverrides && typeof state.runLayoutOverrides === 'object') {
      delete state.runLayoutOverrides[s.data.id];
    }
    state.selected = null;
    queuePersist();
    rebuildScene();
    renderSelection();
    renderRunSetupPanel(null);
  }
}

function renderIsoEntity({ className, kind, x, y, z, innerHtml, onClick }) {
  const shell = document.createElement('div');
  const screen = worldToScreen(x, y);
  const fp = buildingFootprint(kind || 'run');
  shell.className = `entity ${className}`;
  shell.style.left = `${screen.x}px`;
  shell.style.top = `${screen.y}px`;
  shell.style.zIndex = String(worldDepth(z || y, 1000));
  shell.style.setProperty('--footprint-w', `${fp.w}px`);
  shell.style.setProperty('--footprint-h', `${fp.h}px`);
  shell.style.setProperty('--sprite-w', `${fp.spriteW}px`);
  shell.style.setProperty('--sprite-h', `${fp.spriteH}px`);
  shell.innerHTML = `<div class="iso-core">${innerHtml}</div>`;
  shell.onclick = onClick;
  return shell;
}

const NON_TERMINAL_RUN_STATUSES = new Set(['pending', 'running', 'retrying', 'queued', 'claimed', 'in_progress', 'waiting']);
const SUCCESS_RUN_STATUSES = new Set(['done', 'completed', 'success']);
const FAILED_RUN_STATUSES = new Set(['failed', 'error', 'canceled', 'cancelled', 'timeout', 'timed_out']);

function normalizeRunStatus(status){
  return String(status || '').trim().toLowerCase();
}

function normalizeFeatureDraft(raw){
  const src = raw && typeof raw === 'object' ? raw : {};
  const runId = src.runId ? String(src.runId) : '';
  const committed = typeof src.committed === 'boolean'
    ? src.committed
    : !!runId;
  const repo = baseRepoKey(String(src.repo || ''));
  return {
    ...src,
    id: String(src.id || `feature-draft-${Date.now()}`),
    kind: 'feature',
    repo,
    worktreePath: String(src.worktreePath || ''),
    prompt: String(src.prompt || ''),
    runId,
    committed,
    phase: String(src.phase || (committed ? 'running' : 'draft')),
    x: Number(src.x || 0),
    y: Number(src.y || 0),
    port: Number(src.port || 0) || undefined
  };
}

function featureStructureVisualState(building){
  if (!building) return 'draft';
  if (!building.committed || !building.runId) return 'draft';
  const status = normalizeRunStatus(building.run?.status || building.phase || '');
  if (SUCCESS_RUN_STATUSES.has(status)) return 'done';
  if (FAILED_RUN_STATUSES.has(status)) return 'failed';
  if (!status || NON_TERMINAL_RUN_STATUSES.has(status)) return 'in-progress';
  return 'in-progress';
}

function featureStructureClassName(building){
  const visualState = featureStructureVisualState(building);
  if (visualState === 'draft') return 'is-half-transparent';
  if (visualState === 'failed') return 'is-failed';
  return '';
}

function renderWorld(){
  const world = document.getElementById('world');
  const pathLayer = document.getElementById('pathLayer');
  world.innerHTML = '';
  if (pathLayer) pathLayer.innerHTML = '';

  const runTargets = runTargetCenterMap();
  const activeMap = activeRunAgentMap();
  if (pathLayer) {
    (state.bases || []).forEach((base) => {
      (base.runs || []).forEach((run) => {
        const target = runTargets.get(run.id);
        if (!target) return;
        const from = centerPointFor('base', base.x, base.y);
        const sx = from.x;
        const sy = from.y;
        const ex = target.x;
        const ey = target.y;
        const dx = ex - sx;
        const dy = ey - sy;
        const dist = Math.hypot(dx, dy);
        if (dist < 1) return;
        const start = worldToScreen(sx, sy);
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        const active = !!activeMap.get(run.id);
        const line = document.createElement('div');
        line.className = `rts-path ${active ? 'active' : ''}`;
        line.style.left = `${start.x}px`;
        line.style.top = `${start.y}px`;
        line.style.width = `${dist}px`;
        line.style.transform = `rotate(${angle}deg)`;
        pathLayer.appendChild(line);
      });
    });
  }

  state.bases.forEach(base => {
    const movable = base.source === 'custom';
    const basePort = Number(base.port) || getPortForPath(base.repo || '') || 3333;
    const baseLabel = base.portLabel || pathLabel(base.repo || '');
    const el = renderIsoEntity({
      className:`base ${movable ? 'movable' : ''}`,
      kind:'base',
      x:base.x,
      y:base.y,
      innerHtml: `${structureMarkup('base')}<div class="port-chip">${esc(baseLabel)} :${basePort}</div>`,
      onClick:() => { state.selected = { type:'base', data:base }; renderSelection(); }
    });
    if (movable) {
      el.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        if (state.placementMode) return;
        e.stopPropagation();
        const point = screenToWorld(e.clientX, e.clientY);
        state.draggingEntity = {
          type: 'base',
          id: base.id,
          repoPath: base.repo || '',
          offsetX: point.x - base.x,
          offsetY: point.y - base.y
        };
        state.draggingMoved = false;
      });
    }
    world.appendChild(el);
  });

  (state.baseDrafts || []).forEach((draft) => {
    const el = renderIsoEntity({
      className:'base draft-ghost movable',
      kind:'base',
      x:draft.x,
      y:draft.y,
      innerHtml: structureMarkup('base'),
      onClick:() => {
        state.selected = { type:'baseDraft', data:draft };
        renderSelection();
        renderBaseCloneForm(draft);
      }
    });
    el.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      if (state.placementMode) return;
      e.stopPropagation();
      const point = screenToWorld(e.clientX, e.clientY);
      state.draggingEntity = {
        type: 'baseDraft',
        id: draft.id,
        offsetX: point.x - draft.x,
        offsetY: point.y - draft.y
      };
      state.draggingMoved = false;
    });
    world.appendChild(el);
  });

  state.buildings.forEach(b => {
    const status = prettyStatus(b.run?.status || b.phase || 'waiting');
    const color = status === 'done' ? 'var(--ok)' : status === 'failed' ? 'var(--bad)' : 'var(--warn)';
    const movable = true;
    const featureVisualClass = b.kind === 'feature' ? featureStructureClassName(b) : '';
    const className = ['building', featureVisualClass, movable ? 'movable' : ''].filter(Boolean).join(' ');
    const buildPort = Number(b.port) || getPortForPath(b.worktreePath || b.repo || '') || 3334;
    const buildLabel = b.portLabel || pathLabel(b.worktreePath || b.repo || '');
    const el = renderIsoEntity({
      className,
      kind: b.kind === 'feature' ? 'feature' : 'run',
      x:b.x,
      y:b.y,
      innerHtml:`
        ${structureMarkup(b.kind === 'feature' ? 'feature' : 'run')}
        <div class="port-chip">${esc(buildLabel)} :${buildPort}</div>
        <div class="progress" style="position:absolute;left:12px;right:12px;bottom:8px"><div class="bar" style="width:${b.progress || 0}%;background:${color}"></div></div>
      `,
      onClick:() => {
        state.selected = { type:'building', data:b };
        renderSelection();
        if (b.kind === 'feature') renderRunSetupPanel(b.id);
      }
    });
    if (movable) {
      el.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        if (state.placementMode) return;
        e.stopPropagation();
        const point = screenToWorld(e.clientX, e.clientY);
        state.draggingEntity = {
          type: b.kind === 'feature' ? 'feature' : 'run',
          id: b.id,
          runId: b.runId || b.run?.id || (b.kind === 'run' ? b.id : ''),
          repoPath: b.repo || '',
          worktreePath: b.worktreePath || '',
          offsetX: point.x - b.x,
          offsetY: point.y - b.y
        };
        state.draggingMoved = false;
      });
    }
    world.appendChild(el);
  });

  state.units.forEach(u => {
    const el = document.createElement('div');
    const liveEntry = getLiveAgentEntry(u.runId, u.full);
    el.className = `unit ${liveEntry ? (liveEntry.stale ? 'live-stale' : 'live-running') : ''}`;
    if (u.moving) el.classList.add('moving');
    const p = worldToScreen(u.x, u.y);
    el.style.left = `${p.x}px`;
    el.style.top = `${p.y}px`;
    el.style.zIndex = String(worldDepth(u.y, 2000));
    el.title = `${u.label}  model: ${u.model || 'unknown'}${liveEntry ? `  ${liveEntry.stale ? 'stale' : 'running'}` : ''}`;
    el.dataset.runId = u.runId;
    el.dataset.agentId = u.full;
    el.dataset.baseTitle = `${u.label}  model: ${u.model || 'unknown'}`;
    el.onclick = () => { state.selected = { type:'unit', data:u }; renderSelection(); };
    world.appendChild(el);

    for (let i = 0; i < u.subagents; i++) {
      const angle = (Date.now()/620 + i * (Math.PI*2 / u.subagents));
      const sx = u.x + 8 + Math.cos(angle) * 22;
      const sy = u.y + 8 + Math.sin(angle) * 16;
      const sp = worldToScreen(sx, sy);
      const sub = document.createElement('div');
      sub.className = 'subunit';
      sub.style.left = `${sp.x}px`;
      sub.style.top = `${sp.y}px`;
      sub.style.zIndex = String(worldDepth(sy, 1900));
      sub.title = `subagent  ${u.faction}`;
      sub.onclick = () => { state.selected = { type:'subunit', data:u }; renderSelection(); };
      world.appendChild(sub);
    }
  });

  state.buildings.forEach((b) => {
    const status = String(b.run?.status || '').toLowerCase();
    if (!(status === 'completed' || status === 'done')) return;
    if (!b.prUrl) return;
    const pos = worldToScreen(Number(b.x || 0) + 26, Number(b.y || 0) - 42);
    const note = document.createElement('div');
    note.className = 'build-note';
    note.style.left = `${pos.x}px`;
    note.style.top = `${pos.y}px`;
    note.innerHTML = `PR READY<br><a href="${esc(b.prUrl)}" target="_blank" rel="noopener">Open pull request</a>`;
    world.appendChild(note);
  });
}

function renderUnitsLiveState(){
  const nodes = document.querySelectorAll('.unit[data-run-id][data-agent-id]');
  nodes.forEach((node) => {
    const runId = node.getAttribute('data-run-id') || '';
    const agentId = node.getAttribute('data-agent-id') || '';
    const baseTitle = node.getAttribute('data-base-title') || '';
    const liveEntry = getLiveAgentEntry(runId, agentId);
    node.classList.remove('live-running', 'live-stale');
    if (liveEntry) node.classList.add(liveEntry.stale ? 'live-stale' : 'live-running');
    node.title = `${baseTitle}${liveEntry ? `  ${liveEntry.stale ? 'stale' : 'running'}` : ''}`;
  });
}

function renderSkillTree(type, heading){
  const nodes = skillTrees[type] || skillTrees.builder;
  return `<div class="build-card" style="margin-top:8px"><div class="kv"><strong>${heading}</strong></div><div class="skill-grid">${nodes.map(n=>`<div class="skill">${esc(n)}</div>`).join('')}</div></div>`;
}

function renderRunAgentsConsole(run, selectedAgentId){
  const panel = document.getElementById('actionPanel');
  setFeatureMode(false);
  if (!run) {
    panel.innerHTML = `<h3>Action Console</h3><div class="notice">No run selected.</div>`;
    stopAgentStream();
    return;
  }
  const agents = deriveRunAgents(run);
  panel.innerHTML = `
    <h3>Agent Status Console</h3>
    <div class="kv"><strong>Run:</strong> ${esc(run.id.slice(0, 12))}</div>
    <div class="kv"><strong>Task:</strong> ${esc(run.task || '')}</div>
    <div class="notice" id="restartNotice">Select an agent row; restart forces requeue and kick.</div>
    ${renderAgentStatusList(agents, run)}
    <div class="notice" style="margin-top:8px">Read-only terminal stream. No command input available.</div>
  `;
  const rows = panel.querySelectorAll('#assignedAgentList .agent-row');
  rows.forEach(row => {
    row.addEventListener('click', () => {
      const runId = row.getAttribute('data-run');
      const agentId = row.getAttribute('data-agent');
      if (!runId || !agentId) return;
      state.streamSelectionByRun[runId] = agentId;
      startAgentStream(runId, agentId);
      panel.querySelectorAll('#assignedAgentList .agent-row').forEach(r => r.classList.remove('active'));
      row.classList.add('active');
    });
  });
  const restartBtns = panel.querySelectorAll('#assignedAgentList .agent-restart');
  restartBtns.forEach((btn) => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const runId = btn.getAttribute('data-restart-run');
      const agentId = btn.getAttribute('data-restart-agent');
      if (!runId || !agentId) return;
      const restartNotice = panel.querySelector('#restartNotice');
      try {
        btn.disabled = true;
        if (restartNotice) restartNotice.textContent = `Restart requested for ${agentId}...`;
        const rr = await postJson('/api/rts/agent/restart', { runId, agentId });
        state.runs = await json('/api/runs');
        rebuildScene();
        const refreshed = (state.runs || []).find(r => r.id === runId);
        if (refreshed) {
          renderRunAgentsConsole(refreshed, agentId);
          const refreshedNotice = document.querySelector('#actionPanel #restartNotice');
          if (refreshedNotice) refreshedNotice.textContent = rr?.kicked
            ? `Restart accepted for ${agentId}. Step reset and kick sent.`
            : `Restart accepted for ${agentId}. Step reset; waiting for cron fallback.`;
        }
      } catch (err) {
        const message = String(err?.message || err || 'unknown_error');
        const human = message.includes('agent_waiting_not_restartable')
          ? 'Restart rejected: this agent is waiting. Restart a running/failed/done agent instead.'
          : `Restart failed: ${message}`;
        const freshNotice = document.querySelector('#actionPanel #restartNotice');
        if (freshNotice) freshNotice.textContent = human;
        else if (restartNotice) restartNotice.textContent = human;
      } finally {
        btn.disabled = false;
      }
    });
  });
  const redoBtns = panel.querySelectorAll('#assignedAgentList .agent-redo');
  redoBtns.forEach((btn) => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const runId = btn.getAttribute('data-redo-run');
      const restartNotice = panel.querySelector('#restartNotice');
      if (!runId) return;
      try {
        btn.disabled = true;
        if (restartNotice) restartNotice.textContent = 'Redoing PR step for developer...';
        const rr = await postJson('/api/rts/agent/redo-pr', { runId });
        state.runs = await json('/api/runs');
        rebuildScene();
        const refreshed = (state.runs || []).find(r => r.id === runId);
        if (refreshed) renderRunAgentsConsole(refreshed, 'feature-dev/developer');
        if (restartNotice) restartNotice.textContent = rr?.kicked
          ? 'PR step requeued and kicked immediately.'
          : 'PR step requeued; waiting for cron fallback.';
      } catch (err) {
        if (restartNotice) restartNotice.textContent = `Redo failed: ${err.message || err}`;
      } finally {
        btn.disabled = false;
      }
    });
  });
  renderTerminalViewer();
  const preferredAgent = selectedAgentId || state.streamSelectionByRun[run.id] || (state.stream.runId === run.id ? state.stream.agentId : null);
  if (preferredAgent) {
    const row = panel.querySelector(`#assignedAgentList .agent-row[data-agent="${CSS.escape(preferredAgent)}"]`);
    if (row && !(state.stream.runId === run.id && state.stream.agentId === preferredAgent)) row.click();
  }
}

function renderSelection(){

  queuePersist();
  const panel = document.getElementById('selectionPanel');
  const s = state.selected;
  if (!s) {
    panel.innerHTML = `<h3>Selection Panel</h3><div class="notice">Select base/building/unit for RTS-style intel and actions.</div>`;
    return;
  }

  if (s.type === 'base') {
    setFeatureMode(false);
    const b = s.data;
    const basePort = Number(b.port) || getPortForPath(b.repo || '') || 3333;
    const baseLabel = b.portLabel || pathLabel(b.repo || '');
    panel.innerHTML = `<h3>Base Intel</h3><div class="kv"><strong>Repo:</strong> ${esc(b.repo || 'unlinked')}</div><div class="kv"><strong>Role:</strong> ${esc(baseLabel)}</div><div class="kv"><strong>Runtime:</strong> ${runtimeLink(basePort)}</div><div class="kv"><strong>Buildings:</strong> ${(b.runs || []).length}</div>${renderSkillTree('orchestrator','Base Systems')}`;
    stopAgentStream();
    return;
  }
  if (s.type === 'building') {
    const b = s.data;
    if (b.kind === 'feature') {
      setFeatureMode(true);
      const port = Number(b.port) || getPortForPath(b.worktreePath || b.repo || '') || 3334;
      panel.innerHTML = `<h3>Feature Forge</h3><div class="kv"><strong>Repo:</strong> ${esc(b.repo || 'unlinked')}</div><div class="kv"><strong>Worktree:</strong> ${esc(b.worktreePath || '-')}</div><div class="kv"><strong>Runtime:</strong> ${runtimeLink(port)}</div><div class="kv"><strong>Status:</strong> ${esc(prettyStatus(b.run?.status || b.phase || 'draft'))}</div><div class="kv"><strong>Progress:</strong> ${b.progress || 0}%</div>${b.prUrl ? `<a class="pr-link" href="${b.prUrl}" target="_blank">OPEN PULL REQUEST</a>` : '<div class="notice">No PR link detected yet.</div>'}${renderSkillTree('builder','Run Build Matrix')}`;
      if (!isEditingActionPanel()) renderRunSetupPanel(b.id);
      return;
    }
    const port = Number(b.port) || getPortForPath(b.worktreePath || b.repo || '') || 3334;
    panel.innerHTML = `<h3>Structure Status</h3><div class="kv"><strong>Task:</strong> ${esc(b.run.task || '')}</div><div class="kv"><strong>Worktree:</strong> ${esc(b.worktreePath || '-')}</div><div class="kv"><strong>Runtime:</strong> ${runtimeLink(port)}</div><div class="kv"><strong>Status:</strong> ${esc(prettyStatus(b.run.status || 'waiting'))}</div><div class="kv"><strong>Progress:</strong> ${b.progress}%</div>${b.prUrl ? `<a class="pr-link" href="${b.prUrl}" target="_blank">OPEN PULL REQUEST</a>` : '<div class="notice">No PR link detected yet.</div>'}${renderSkillTree('builder','Run Build Matrix')}`;
    renderRunAgentsConsole(b.run);
    return;
  }
  if (s.type === 'unit') {
    setFeatureMode(false);
    const u = s.data;
    panel.innerHTML = `<h3>Unit Profile</h3><div class="kv"><strong>Agent:</strong> ${esc(u.label)}</div><div class="kv"><strong>Model:</strong> <span class="badge">${esc(u.model || 'unknown')}</span></div><div class="kv"><strong>Subagents:</strong> ${u.subagents}</div>${renderSkillTree('architect','Operator Skill Grid')}`;
    const run = (state.runs || []).find(r => r.id === u.runId);
    renderRunAgentsConsole(run, u.full);
    return;
  }
  if (s.type === 'subunit') {
    setFeatureMode(false);
    const u = s.data;
    panel.innerHTML = `<h3>Subagent Drone</h3><div class="kv"><strong>Parent unit:</strong> ${esc(u.label)}</div><div class="kv"><strong>Faction:</strong> ${esc(u.faction)}</div>${renderSkillTree('subagent','Subagent Modules')}`;
    stopAgentStream();
    return;
  }
  if (s.type === 'baseDraft') {
    setFeatureMode(false);
    panel.innerHTML = `<h3>Base Placement Draft</h3><div class="notice">Configure git clone details in Action Console to finalize this base.</div>`;
    stopAgentStream();
    return;
  }
}

function renderBaseCloneForm(draft){
  setFeatureMode(false);
  const panel = document.getElementById('actionPanel');
  const repoOptions = (state.localRepos || []).map(r => {
    const suggested = Number(r.suggestedPort) || getPortForPath(r.path) || '';
    const suffix = suggested ? `  :${suggested}` : '';
    return `<option value="${esc(r.path)}">${esc(r.name)}  ${esc(r.path)}${suffix}</option>`;
  }).join('');
  panel.innerHTML = `
    <h3>Base Setup</h3>
    <div class="kv"><strong>Placement:</strong> x ${Math.round(draft.x)}, y ${Math.round(draft.y)}</div>
    <label class="kv">Use existing local repo
      <select id="existingRepoSelect">
        <option value=""> none / create via clone </option>
        ${repoOptions}
      </select>
    </label>
    <label class="kv">Repository URL (for clone)
      <input id="cloneRepoUrl" placeholder="https://github.com/org/repo.git" value="${esc(draft.repoUrl || '')}" />
    </label>
    <label class="kv">Target path
      <input id="cloneTargetPath" placeholder="../repo-worktree" value="${esc(draft.targetPath || '')}" />
    </label>
    <label class="kv">Base port
      <input id="basePortInput" type="number" min="1" max="65535" value="${esc(String(draft.port || 3333))}" />
    </label>
    <button id="saveBaseCloneBtn">Create Base</button>
    <div class="notice" style="margin-top:7px" id="baseMutationNotice">Select an existing repo OR provide clone URL + target path.</div>
  `;

  const existingRepoSelect = document.getElementById('existingRepoSelect');
  existingRepoSelect.addEventListener('change', (e) => {
    draft.existingRepoPath = e.target.value || '';
    if (draft.existingRepoPath) {
      draft.targetPath = draft.existingRepoPath;
      const repoMeta = (state.localRepos || []).find((r) => r.path === draft.existingRepoPath);
      draft.port = Number(repoMeta?.suggestedPort) || getPortForPath(draft.existingRepoPath) || draft.port || 3333;
      const pathInput = document.getElementById('cloneTargetPath');
      if (pathInput) pathInput.value = draft.targetPath;
      const portInput = document.getElementById('basePortInput');
      if (portInput) portInput.value = String(draft.port);
    }
    queuePersist();
  });
  document.getElementById('cloneRepoUrl').addEventListener('input', e => { draft.repoUrl = e.target.value; queuePersist(); });
  document.getElementById('cloneTargetPath').addEventListener('input', e => { draft.targetPath = e.target.value; queuePersist(); });
  document.getElementById('basePortInput').addEventListener('input', e => {
    draft.port = Number(e.target.value) || draft.port || 3333;
    queuePersist();
  });

  const submitBaseDraft = async () => {
    const usingExisting = !!draft.existingRepoPath;
    const notice = document.getElementById('baseMutationNotice');
    try {
      if (!usingExisting && (!draft.repoUrl || !draft.targetPath)) throw new Error('Choose an existing repo, or provide repo URL and target path.');
      if (usingExisting && !draft.targetPath) throw new Error('Existing repo path is required.');

      notice.textContent = 'Creating base...';
      const payload = usingExisting
        ? { useExistingRepoPath: draft.existingRepoPath }
        : { repoUrl: draft.repoUrl, targetPath: draft.targetPath };
      const result = await postJson('/api/rts/base/clone', { ...payload, placement: { x: draft.x, y: draft.y } });
      const base = {
        id:`custom-base-${Date.now()}`,
        x:draft.x,
        y:draft.y,
        repo:result.repoPath,
        port: Number(draft.port) || getPortForPath(result.repoPath) || 3333,
        portLabel: pathLabel(result.repoPath),
        source:'custom',
        cloneMeta: {
          mode: result.mode,
          repoUrl: draft.repoUrl || '',
          targetPath: draft.targetPath || result.repoPath,
          existingRepoPath: draft.existingRepoPath || ''
        },
        runs:[]
      };
      setPortForPath(base.repo, base.port);
      removeBaseDraftById(draft.id);
      state.customBases.push(base);
      state.selected = { type:'base', data:base };
      queuePersist();
      panel.innerHTML = `<h3>Base Setup</h3><div class="kv"><strong>Base created.</strong></div><div class="kv"><strong>Repo:</strong> ${esc(base.repo)}</div><div class="kv"><strong>Mode:</strong> ${esc(result.mode)}</div><div class="notice">Ready for feature worktree and run setup.</div>`;
      rebuildScene();
      renderSelection();
    } catch (err) {
      notice.textContent = `Error: ${err.message || err}`;
    }
  };
  document.getElementById('saveBaseCloneBtn').onclick = submitBaseDraft;
  ['cloneRepoUrl', 'cloneTargetPath'].forEach((id) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('keydown', (e) => {
      if (e.key !== 'Enter') return;
      e.preventDefault();
      submitBaseDraft();
    });
  });
}

function statusTone(status){
  if (status === 'done') return 'var(--ok)';
  if (status === 'running') return 'var(--warn)';
  if (status === 'stale') return '#ff8faa';
  if (status === 'failed') return 'var(--bad)';
  if (status === 'skipped') return '#9fb5c6';
  return '#6b859e';
}

function prettyStatus(status){
  if (status === 'pending') return 'waiting';
  return status || 'idle';
}

function canRestartAgentStatus(status){
  const s = String(status || '').toLowerCase();
  return s !== 'waiting' && s !== 'idle' && s !== 'skipped';
}

function findRelevantRun(draft){
  if (!draft) return null;
  if (draft.runId) return (state.runs || []).find(r => r.id === draft.runId) || null;
  return null;
}

function deriveRunAgents(run){
  const map = new Map();
  (run?.steps || []).forEach(step => {
    if (!step.agent_id) return;
    if (!map.has(step.agent_id)) map.set(step.agent_id, []);
    map.get(step.agent_id).push(step.status || 'pending');
  });
  return Array.from(map.entries()).map(([agentId, statuses]) => {
    const live = getLiveAgentEntry(run?.id, agentId);
    let status = 'waiting';
    if (live && !live.stale) status = 'running';
    else if (live && live.stale) status = 'stale';
    else if (statuses.includes('running')) status = 'running';
    else if (statuses.includes('failed')) status = 'failed';
    else if (statuses.every(s => s === 'done' || s === 'skipped')) status = 'done';
    else if (statuses.includes('pending')) status = 'waiting';
    return { agentId, status };
  });
}

function prettyStepName(stepId){
  const raw = String(stepId || '').trim().toLowerCase();
  if (!raw) return 'Step';
  if (raw === 'pr') return 'PR creation';
  return raw
    .split(/[_-]+/)
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

function resolveStepLabel(run, stepRef){
  if (!stepRef) return '';
  const row = (run?.steps || []).find((step) => step.id === stepRef || step.step_id === stepRef);
  return String(row?.step_id || stepRef || '');
}

function summarizeSingleLine(text, max = 180){
  return String(text || '').replace(/\s+/g, ' ').trim().slice(0, max);
}

function detectPrBlocker(text){
  const raw = String(text || '').toLowerCase();
  if (!raw) return '';
  if (/gh auth|not logged in|authentication failed/.test(raw)) {
    return 'GitHub auth looks missing. Run `gh auth status` in the worktree and sign in if needed.';
  }
  if (/no commits between|nothing to compare/.test(raw)) {
    return 'GitHub reports no commits between base and head. Commit and push changes before creating a PR.';
  }
  if (/has no upstream branch|set-upstream|must push/.test(raw)) {
    return 'Branch is not pushed with upstream. Push the branch, then retry PR creation.';
  }
  if (/already exists|pull request already/.test(raw)) {
    return 'A PR may already exist for this branch. Check existing PRs before retrying.';
  }
  if (/resource not accessible|forbidden|permission denied/.test(raw)) {
    return 'GitHub token/permissions look insufficient for PR creation.';
  }
  if (/could not resolve host|timed out|network/.test(raw)) {
    return 'Network/GitHub API connectivity issue while creating PR.';
  }
  return '';
}

function buildPrStatusLines(run, events){
  if (String(run?.workflow_id || '') !== 'feature-dev') return [];
  const prStep = (run?.steps || []).find((step) => String(step.step_id || '').toLowerCase() === 'pr');
  if (!prStep) return [];
  const prUrl = extractPrUrl(run);
  if (prUrl) return [`[pr] Pull request detected: ${prUrl}`];

  const status = String(prStep.status || 'waiting');
  const runStatus = String(run?.status || 'running');
  if ((status === 'waiting' || status === 'pending') && runStatus === 'running') return [];

  const lines = [];
  if (status === 'failed') lines.push('[pr] PR step failed, so no pull request was created.');
  else if (status === 'done') lines.push('[pr] PR step completed but no pull request URL was found.');
  else if (status === 'running') lines.push('[pr] PR step is running. Waiting for `gh pr create` output.');
  else lines.push(`[pr] PR step status: ${status}.`);

  const lastPrEvent = [...(events || [])].reverse().find((evt) => {
    const stepLabel = resolveStepLabel(run, evt.stepId).toLowerCase();
    return stepLabel === 'pr' || (evt.event === 'run.failed' && runStatus === 'failed');
  });
  const detail = String(lastPrEvent?.detail || prStep.output || '').trim();
  const blocker = detectPrBlocker(detail);
  if (blocker) lines.push(`[pr] ${blocker}`);
  else if (detail) lines.push(`[pr] Last detail: ${summarizeSingleLine(detail, 240)}`);
  return lines;
}

function formatEventLine(evt, stepLabel = ''){
  const t = new Date(evt.ts || Date.now());
  const hhmmss = t.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });
  return `[${hhmmss}] ${formatActivityDesc(evt, stepLabel)}`;
}

function formatActivityDesc(evt, stepLabel = '') {
  const e = evt.event;
  const story = evt.storyTitle ? `${evt.storyId}: "${evt.storyTitle}"` : (evt.storyId || '');
  const stepName = prettyStepName(stepLabel);
  const hasStep = !!stepLabel;
  switch (e) {
    case 'run.started': return 'Run started';
    case 'run.completed': return 'Run completed';
    case 'run.failed': return `Run failed${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'step.pending': return hasStep ? `${stepName} pending` : 'Step pending';
    case 'step.running': return hasStep ? `${stepName} started` : 'Claimed step';
    case 'step.done': return hasStep ? `${stepName} completed` : 'Step completed';
    case 'step.failed': return hasStep
      ? `${stepName} failed${evt.detail ? `: ${evt.detail}` : ''}`
      : `Step failed${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'step.timeout': return hasStep
      ? `${stepName} timed out${evt.detail ? `: ${evt.detail}` : ''}`
      : `Step timed out${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'story.started': return `Claimed story ${story}`;
    case 'story.done': return `Completed ${story}`;
    case 'story.verified': return `Verified ${story}`;
    case 'story.retry': return `Retry ${story}${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'story.failed': return `Story failed ${story}${evt.detail ? `: ${evt.detail}` : ''}`;
    case 'pipeline.advanced': return hasStep ? `Pipeline advanced to ${stepName}` : 'Pipeline advanced';
    default: return `${e}${evt.detail ? `: ${evt.detail}` : ''}`;
  }
}

async function startAgentStream(runId, agentId){
  if (state.stream.runId === runId && state.stream.agentId === agentId) return;
  stopAgentStream();
  state.stream = { ...state.stream, runId, agentId, targetLines: [], displayedLines: [], stepStatus:'idle', loading:true };
  renderTerminalViewer();

  const poll = async () => {
    if (!state.stream.runId || !state.stream.agentId) return;
    try {
      const [events, run] = await Promise.all([
        json(`/api/runs/${state.stream.runId}/events`),
        json(`/api/runs/${state.stream.runId}`)
      ]);
      const runActivityLines = (events || []).map((evt) => {
        const t = new Date(evt.ts || Date.now());
        const time = t.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });
        const stepLabel = resolveStepLabel(run, evt.stepId);
        const agentShort = evt.agentId ? String(evt.agentId).split('/').pop() : '--';
        return `[${time}] ${agentShort} ${formatActivityDesc(evt, stepLabel)}`;
      });
      const agentSteps = (run.steps || []).filter(step => step.agent_id === state.stream.agentId);
      const agentStepIdSet = new Set(agentSteps.map((s) => s.id));
      const agentEvents = (events || [])
        .filter((evt) => {
          if (evt.agentId === state.stream.agentId) return true;
          if (evt.stepId && agentStepIdSet.has(evt.stepId)) return true;
          return false;
        })
        .map((evt) => formatEventLine(evt, resolveStepLabel(run, evt.stepId)));
      const stepOutputs = (run.steps || [])
        .filter(step => step.agent_id === state.stream.agentId && step.output)
        .flatMap(step => String(step.output).split('\n').filter(Boolean).map(line => `[${step.step_id}] ${line}`));
      const failedStep = agentSteps.find((step) => step.status === 'failed');
      const runningStep = agentSteps.find((step) => step.status === 'running');
      const fallback = (!agentEvents.length && !stepOutputs.length && failedStep)
        ? [`[${failedStep.step_id}] STATUS: failed`, failedStep.output ? String(failedStep.output) : 'No output captured for failed step.']
        : [];
      if (failedStep && failedStep.output && !stepOutputs.length) {
        fallback.push(`[${failedStep.step_id}] FAILURE: ${String(failedStep.output).slice(0, 800)}`);
      }
      if (!agentEvents.length && !stepOutputs.length && !failedStep && agentSteps.length) {
        const newest = [...agentSteps].sort((a, b) => Date.parse(String(b.updated_at || 0)) - Date.parse(String(a.updated_at || 0)))[0];
        if (newest) fallback.push(`[${newest.step_id}] ${prettyStatus(newest.status)}  last update ${newest.updated_at || 'unknown'}`);
      }
      if (!agentEvents.length && !stepOutputs.length && !failedStep && runningStep) {
        fallback.push(`[${runningStep.step_id}] Agent is running. Waiting for first output...`);
      }
      if (!agentEvents.length && !stepOutputs.length && runActivityLines.length) {
        fallback.push('[activity] No agent-scoped lines yet; showing latest run activity:');
        fallback.push(...runActivityLines.slice(-12));
      }
      const prStatusLines = buildPrStatusLines(run, events);
      const unique = [...new Set([...agentEvents, ...stepOutputs, ...fallback, ...prStatusLines])];
      state.stream.targetLines = unique;
      state.stream.stepStatus = deriveRunAgents(run).find(a => a.agentId === state.stream.agentId)?.status || 'idle';
      state.stream.loading = false;
      renderTerminalViewer();
    } catch {
      state.stream.loading = false;
      renderTerminalViewer();
    }
  };

  await poll();
  state.stream.pollTimer = setInterval(poll, 3000);
  state.stream.revealTimer = setInterval(() => {
    if (!state.stream.runId || !state.stream.agentId) return;
    const nextIndex = state.stream.displayedLines.length;
    if (nextIndex >= state.stream.targetLines.length) return;
    state.stream.displayedLines.push(state.stream.targetLines[nextIndex]);
    renderTerminalViewer();
  }, 90);
}

function stopAgentStream(){
  if (state.stream.pollTimer) clearInterval(state.stream.pollTimer);
  if (state.stream.revealTimer) clearInterval(state.stream.revealTimer);
  state.stream.pollTimer = null;
  state.stream.revealTimer = null;
}

function renderTerminalViewer(){
  const host = document.getElementById('terminalViewerHost');
  if (!host) return;
  if (!state.stream.runId || !state.stream.agentId) {
    host.innerHTML = `<div class="notice" style="margin-top:8px">Click an agent row to view live read-only output stream.</div>`;
    return;
  }
  const content = state.stream.displayedLines.length
    ? esc(state.stream.displayedLines.join('\n'))
    : (state.stream.loading ? 'Connecting to run events...' : 'No output yet for this agent.');
  host.innerHTML = `
    <div class="term-wrap">
      <div class="term-head">
        <span>read-only terminal  ${esc(state.stream.agentId)}</span>
        <div class="term-actions">
          <span><span class="status-dot" style="background:${statusTone(state.stream.stepStatus)}"></span>${esc(prettyStatus(state.stream.stepStatus))}</span>
          <button class="term-copy" id="copyAgentOutputBtn" type="button">copy</button>
        </div>
      </div>
      <pre class="term-view">${content}</pre>
    </div>
  `;
  const term = host.querySelector('.term-view');
  if (term) term.scrollTop = term.scrollHeight;
  const copyBtn = host.querySelector('#copyAgentOutputBtn');
  if (copyBtn) {
    copyBtn.onclick = async () => {
      const lines = state.stream.displayedLines.length ? state.stream.displayedLines : state.stream.targetLines;
      const text = lines.length ? lines.join('\n') : 'No output yet for this agent.';
      try {
        await navigator.clipboard.writeText(text);
        copyBtn.textContent = 'copied';
      } catch {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.setAttribute('readonly', 'true');
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand('copy'); copyBtn.textContent = 'copied'; }
        catch { copyBtn.textContent = 'copy failed'; }
        document.body.removeChild(ta);
      }
      setTimeout(() => { copyBtn.textContent = 'copy'; }, 1200);
    };
  }
}

function renderAgentStatusList(agents, run){
  const rows = agents.length
    ? agents.map(a => `
      <div class="agent-row ${state.stream.agentId === a.agentId && state.stream.runId === run?.id ? 'active' : ''}" data-agent="${esc(a.agentId)}" data-run="${esc(run?.id || '')}">
        <div class="agent-meta"><span class="status-dot" style="background:${statusTone(a.status)}"></span><span class="agent-name" title="${esc(a.agentId)}">${esc(baseAgentId(a.agentId))}</span></div>
        <div class="agent-actions">
          <span class="badge">${esc(prettyStatus(a.status))}</span>
          ${canRestartAgentStatus(a.status)
            ? `<button class="agent-restart" data-restart-agent="${esc(a.agentId)}" data-restart-run="${esc(run?.id || '')}">restart</button>`
            : ''}
          ${baseAgentId(a.agentId).toLowerCase().endsWith('/developer') ? `<button class="agent-redo" data-redo-run="${esc(run?.id || '')}" title="Requeue PR step for developer">redo</button>` : ''}
        </div>
      </div>`).join('')
    : '<div class="notice">No assigned agents yet.</div>';
  return `<div class="build-card" style="margin-top:8px"><div class="kv"><strong>Assigned Agents</strong></div><div class="agent-list" id="assignedAgentList">${rows}</div><div id="terminalViewerHost"></div></div>`;
}

function renderRunSetupPanel(targetDraftId){
  const panel = document.getElementById('actionPanel');
  let draft = targetDraftId ? state.featureBuildings.find(d => d.id === targetDraftId) : state.featureBuildings[state.featureBuildings.length - 1];
  if (!draft && targetDraftId) {
    const inferred = (state.buildings || []).find((b) => b.id === targetDraftId && b.kind === 'feature');
    if (inferred) {
      draft = {
        id: inferred.id,
        kind: 'feature',
        phase: inferred.phase || inferred.run?.status || 'running',
        committed: !!(inferred.committed || inferred.runId),
        runId: inferred.runId || inferred.run?.id || null,
        x: inferred.x,
        y: inferred.y,
        repo: inferred.repo || '',
        worktreePath: inferred.worktreePath || '',
        port: Number(inferred.port) || getPortForPath(inferred.worktreePath || inferred.repo || '') || 3334,
        prompt: inferred.run?.task || '',
      };
      state.featureBuildings.push(draft);
      queuePersist();
    }
  }
  if (!draft) {
    setFeatureMode(false);
    panel.innerHTML = `<h3>Action Console</h3><div class="notice">Use command cards to place Base or Feature Request structures.</div>`;
    stopAgentStream();
    return;
  }
  setFeatureMode(true);
  if (!draft.worktreePath) draft.worktreePath = getWorktreeDefault(draft.repo || 'antfarm');
  if (typeof draft.prompt !== 'string') draft.prompt = String(draft.prompt || '');
  const run = draft.runId ? (state.runs || []).find(r => r.id === draft.runId) : null;
  const hasRun = !!run;
  const isDraft = !draft.committed;
  if (!draft.port) {
    draft.port = getPortForPath(draft.worktreePath || '') || getPortForPath(draft.repo || '') || 3334;
  }

  panel.innerHTML = `
    <h3>${isDraft ? 'Feature Draft Setup' : 'Feature Run Console'}</h3>
    <div class="kv"><strong>Repo:</strong> ${esc(draft.repo)}</div>
    <label class="kv">Worktree path
      <input id="worktreePath" value="${esc(draft.worktreePath)}" />
    </label>
    <div class="kv"><strong>Runtime:</strong> ${runtimeLink(draft.port || 3334)}</div>
    <label class="kv">Feature prompt
      <textarea id="featurePrompt" rows="8" placeholder="Describe detailed scope, constraints, and acceptance criteria...">${esc(draft.prompt)}</textarea>
    </label>
    ${hasRun ? renderAgentStatusList(deriveRunAgents(run), run) : ''}
    <button id="launchFeatureRunBtn" style="margin-top:8px">${isDraft ? 'Create Worktree + Start Run' : 'Relaunch Run'}</button>
    <button id="preparePrBtn" style="margin-top:6px">Check / Prepare PR Link</button>
    <div class="notice" style="margin-top:8px" id="featureMutationNotice">Ready to execute backend actions.</div>
  `;

  document.getElementById('worktreePath').addEventListener('input', e => { draft.worktreePath = e.target.value; queuePersist(); });
  document.getElementById('featurePrompt').addEventListener('input', e => { draft.prompt = e.target.value; queuePersist(); });

  const mutationNotice = document.getElementById('featureMutationNotice');
  let launchInFlight = false;
  document.getElementById('launchFeatureRunBtn').addEventListener('click', async () => {
    if (launchInFlight) return;
    launchInFlight = true;
    const launchBtn = document.getElementById('launchFeatureRunBtn');
    if (launchBtn) launchBtn.disabled = true;
    try {
      mutationNotice.textContent = 'Creating worktree + starting workflow run...';
      const branchName = `feature/${(draft.prompt || 'task').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'').slice(0,32) || 'task'}-${Date.now().toString().slice(-5)}`;
      const previousRunId = draft.runId || null;
      const draftId = String(draft.id || '');
      const draftX = Number(draft.x || 0);
      const draftY = Number(draft.y || 0);
      const runResult = await postJson('/api/rts/feature/run', {
        workflowId: 'feature-dev',
        taskTitle: draft.prompt || `Feature request for ${draft.repo}`,
        prompt: draft.prompt,
        baseRepoPath: draft.repo,
        worktreePath: draft.worktreePath,
        branchName,
        draftId,
        draftX,
        draftY,
        draftPort: Number(draft.port || 0) || null
      });

      const latestRuns = await json('/api/runs');
      let launchedRunId = String(runResult?.run?.id || '');
      const launchedWorktree = absolutizePath(String(runResult?.worktreePath || draft.worktreePath || ''), String(draft.repo || ''));
      const layoutEntityId = String(runResult?.layout?.id || draftId || draft.id || '');
      if (layoutEntityId) draft.id = layoutEntityId;
      if (!launchedRunId) {
        const matchedRun = (latestRuns || []).find((r) => {
          const ctx = parseContext(r);
          const runWt = absolutizePath(String(ctx.worktreePath || ''), String(ctx.baseRepoPath || ctx.repoPath || ''));
          return !!runWt && !!launchedWorktree && runWt === launchedWorktree;
        });
        if (matchedRun?.id) launchedRunId = String(matchedRun.id);
      }
      draft.worktreePath = runResult.worktreePath || draft.worktreePath;
      draft.port = Number(draft.port) || getPortForPath(draft.worktreePath || '') || 3334;
      setPortForPath(draft.worktreePath, draft.port);
      draft.runId = launchedRunId || draft.runId;
      draft.phase = 'running';
      draft.committed = true;
      draft.x = draftX;
      draft.y = draftY;
      state.featureBuildings = (state.featureBuildings || []).filter((fb) => {
        if (fb === draft) return true;
        if (!fb) return false;
        const sameRun = launchedRunId && String(fb.runId || '') === launchedRunId;
        if (sameRun) return false;
        const fbWt = absolutizePath(String(fb.worktreePath || ''), String(fb.repo || ''));
        const sameWorktreeDraft = !String(fb.runId || '') && !!launchedWorktree && fbWt === launchedWorktree;
        return !sameWorktreeDraft;
      });
      if (previousRunId && previousRunId !== draft.runId && state.runLayoutOverrides && typeof state.runLayoutOverrides === 'object') {
        delete state.runLayoutOverrides[previousRunId];
      }
      const runLabel = launchedRunId ? launchedRunId.slice(0, 12) : 'pending';
      mutationNotice.textContent = `Run started: ${runLabel} (${runResult.branchName})`;
      await persistNow();
      state.runs = latestRuns;
      rebuildScene();
    } catch (err) {
      mutationNotice.textContent = `Error: ${err.message || err}`;
    } finally {
      launchInFlight = false;
      const btn = document.getElementById('launchFeatureRunBtn');
      if (btn) btn.disabled = false;
    }
  });

  document.getElementById('preparePrBtn').addEventListener('click', async () => {
    try {
      const latestRun = draft.runId ? (state.runs || []).find(r => r.id === draft.runId) : null;
      if (!latestRun) throw new Error('No run found for this draft/repo yet.');
      mutationNotice.textContent = 'Checking PR status...';
      const pr = await fetch('/api/pr/prepare', {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ runId: latestRun.id })
      }).then(async (r) => ({ ok:r.ok, data: await r.json() }));
      if (pr.ok && pr.data?.prUrl) mutationNotice.textContent = `PR detected: ${pr.data.prUrl}`;
      else mutationNotice.textContent = pr.data?.next ? `PR waiting: ${pr.data.next}` : `PR status: ${pr.data?.error || 'unknown'}`;
    } catch (err) {
      mutationNotice.textContent = `Error: ${err.message || err}`;
    }
  });

  if (hasRun) {
    const agentRows = panel.querySelectorAll('#assignedAgentList .agent-row');
    agentRows.forEach(row => {
      row.addEventListener('click', () => {
        const runId = row.getAttribute('data-run');
        const agentId = row.getAttribute('data-agent');
        if (!runId || !agentId) return;
        state.streamSelectionByRun[runId] = agentId;
        startAgentStream(runId, agentId);
        panel.querySelectorAll('#assignedAgentList .agent-row').forEach(r => r.classList.remove('active'));
        row.classList.add('active');
      });
    });
    const restartBtns = panel.querySelectorAll('#assignedAgentList .agent-restart');
    restartBtns.forEach((btn) => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const runId = btn.getAttribute('data-restart-run');
        const agentId = btn.getAttribute('data-restart-agent');
        if (!runId || !agentId) return;
        try {
          btn.disabled = true;
          if (mutationNotice) mutationNotice.textContent = `Restart requested for ${agentId}...`;
          const rr = await postJson('/api/rts/agent/restart', { runId, agentId });
          state.runs = await json('/api/runs');
          rebuildScene();
          renderRunSetupPanel(draft.id);
          const mutationNotice = document.getElementById('featureMutationNotice');
          if (mutationNotice) mutationNotice.textContent = rr?.kicked
            ? `Restart accepted for ${agentId}. Step reset and kick sent.`
            : `Restart accepted for ${agentId}. Step reset; waiting for cron fallback.`;
        } catch (err) {
          const message = String(err?.message || err || 'unknown_error');
          const human = message.includes('agent_waiting_not_restartable')
            ? 'Restart rejected: this agent is waiting. Restart a running/failed/done agent instead.'
            : `Restart failed: ${message}`;
          const mutationNotice = document.getElementById('featureMutationNotice');
          if (mutationNotice) mutationNotice.textContent = human;
        } finally {
          btn.disabled = false;
        }
      });
    });
    const redoBtns = panel.querySelectorAll('#assignedAgentList .agent-redo');
    redoBtns.forEach((btn) => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const runId = btn.getAttribute('data-redo-run');
        if (!runId) return;
        try {
          btn.disabled = true;
          const mutationNotice = document.getElementById('featureMutationNotice');
          if (mutationNotice) mutationNotice.textContent = 'Redoing PR step for developer...';
          const rr = await postJson('/api/rts/agent/redo-pr', { runId });
          state.runs = await json('/api/runs');
          rebuildScene();
          renderRunSetupPanel(draft.id);
          if (mutationNotice) mutationNotice.textContent = rr?.kicked
            ? 'PR step requeued and kicked immediately.'
            : 'PR step requeued; waiting for cron fallback.';
        } catch (err) {
          const mutationNotice = document.getElementById('featureMutationNotice');
          if (mutationNotice) mutationNotice.textContent = `Redo failed: ${err.message || err}`;
        } finally {
          btn.disabled = false;
        }
      });
    });
    renderTerminalViewer();
    const activeRow = panel.querySelector('#assignedAgentList .agent-row .badge')?.closest('.agent-row');
    const runningRow = [...agentRows].find((row) => (row.textContent || '').toLowerCase().includes('running'));
    const pinnedAgent = state.streamSelectionByRun[run.id] || (state.stream.runId === run.id ? state.stream.agentId : null);
    const pinnedRow = pinnedAgent ? panel.querySelector(`#assignedAgentList .agent-row[data-agent="${CSS.escape(pinnedAgent)}"]`) : null;
    const preferred = pinnedRow || runningRow || activeRow || agentRows[0];
    if (preferred) {
      const runId = preferred.getAttribute('data-run');
      const agentId = preferred.getAttribute('data-agent');
      if (!(runId && agentId && state.stream.runId === runId && state.stream.agentId === agentId)) preferred.click();
    }
  } else {
    stopAgentStream();
  }
}

// controls
const worldEl = document.getElementById('world');
const worldWrapEl = document.getElementById('worldWrap');
const placementLayerEl = document.getElementById('placementLayer');
let dragBuildingType = null;
document.getElementById('cancelPlacementBtn').addEventListener('click', () => setPlacement(null));
document.getElementById('deleteSelectedBtn').addEventListener('click', () => deleteSelectedStructure());

// Placement must win over any entity drag/select path.
worldWrapEl.addEventListener('mousedown', (e) => {
  if (!state.placementMode) return;
  if (e.button !== 0) return;
  e.preventDefault();
  e.stopPropagation();
  const point = localPointInWorld(e);
  const snapped = snapPlacement(state.placementMode, point.x, point.y);
  if (state.placementMode === 'base') placeBaseAt(snapped.x, snapped.y);
  if (state.placementMode === 'feature') placeFeatureAt(snapped.x, snapped.y);
  state.suppressWorldClick = false;
  setPlacement(null);
}, true);

document.querySelectorAll('.palette-card[data-building]').forEach((card) => {
  card.addEventListener('click', () => setPlacement(card.getAttribute('data-building')));
  card.addEventListener('dragstart', (e) => {
    const kind = card.getAttribute('data-building');
    dragBuildingType = kind;
    setPlacement(kind);
    e.dataTransfer?.setData('text/plain', kind || '');
    worldWrapEl.classList.add('drop-armed');
  });
  card.addEventListener('dragend', () => {
    dragBuildingType = null;
    worldWrapEl.classList.remove('drop-armed');
    hidePlacementGhost();
  });
});

worldWrapEl.addEventListener('dragover', (e) => {
  if (!dragBuildingType) return;
  e.preventDefault();
  const point = localPointInWorld(e);
  showPlacementGhost(dragBuildingType, point.x, point.y);
});
worldWrapEl.addEventListener('drop', (e) => {
  if (!dragBuildingType) return;
  e.preventDefault();
  const point = localPointInWorld(e);
  const snapped = snapPlacement(dragBuildingType, point.x, point.y);
  if (dragBuildingType === 'base') placeBaseAt(snapped.x, snapped.y);
  if (dragBuildingType === 'feature') placeFeatureAt(snapped.x, snapped.y);
  dragBuildingType = null;
  worldWrapEl.classList.remove('drop-armed');
  setPlacement(null);
});
worldWrapEl.addEventListener('dragleave', (e) => {
  if (!dragBuildingType) return;
  if (e.relatedTarget && worldWrapEl.contains(e.relatedTarget)) return;
  hidePlacementGhost();
});

document.addEventListener('keydown', (e) => {
  if (state.featureMode && !e.target?.closest?.('input,textarea,select') && (e.key === 'ArrowDown' || e.key === 'ArrowUp')) {
    const rows = [...document.querySelectorAll('#assignedAgentList .agent-row')];
    if (rows.length) {
      e.preventDefault();
      const currentIndex = rows.findIndex((row) => row.classList.contains('active'));
      const dir = e.key === 'ArrowDown' ? 1 : -1;
      const nextIndex = currentIndex < 0 ? (dir > 0 ? 0 : rows.length - 1) : (currentIndex + dir + rows.length) % rows.length;
      rows[nextIndex].click();
      rows[nextIndex].scrollIntoView({ block: 'nearest' });
      return;
    }
  }
  if (e.target && ['INPUT','TEXTAREA','SELECT'].includes(e.target.tagName)) return;
  if (e.key === 'b' || e.key === 'B') setPlacement('base');
  if (e.key === 'f' || e.key === 'F') setPlacement('feature');
  if (e.key === 'Escape') {
    cancelActiveFeatureDraft();
    setPlacement(null);
  }
  if (e.key === 'Delete' || e.key === 'Backspace') deleteSelectedStructure();
});

const handlePointerMove = (e) => {
  if (state.cameraDrag.active) {
    state.camera.x = state.cameraDrag.originX - (e.clientX - state.cameraDrag.startX);
    state.camera.y = state.cameraDrag.originY - (e.clientY - state.cameraDrag.startY);
    updateCameraVisuals();
    rebuildScene();
    const kind = dragBuildingType || state.placementMode;
    if (kind) {
      const point = localPointInWorld(e);
      showPlacementGhost(kind, point.x, point.y);
    }
    return;
  }
  if (state.draggingEntity) {
    const autoPanned = edgeAutoPan(e.clientX, e.clientY);
    const point = localPointInWorld(e);
    const kind = (state.draggingEntity.type === 'base' || state.draggingEntity.type === 'baseDraft') ? 'base' : 'feature';
    const snapped = snapPlacement(kind, point.x - state.draggingEntity.offsetX + (buildingFootprint(kind).w / 2), point.y - state.draggingEntity.offsetY + (buildingFootprint(kind).h / 2));
    state.draggingMoved = true;
    if (state.draggingEntity.type === 'base') updateCustomBasePosition(state.draggingEntity.id, snapped.x, snapped.y);
    else if (state.draggingEntity.type === 'baseDraft') updateBaseDraftPosition(state.draggingEntity.id, snapped.x, snapped.y);
    else if (state.draggingEntity.type === 'feature') updateFeaturePosition(state.draggingEntity.id, snapped.x, snapped.y);
    else updateRunBuildingPosition(state.draggingEntity.id, snapped.x, snapped.y);
    rebuildScene();
    if (autoPanned) queuePersist();
    return;
  }
  const kind = dragBuildingType || state.placementMode;
  if (!kind) return;
  const point = localPointInWorld(e);
  showPlacementGhost(kind, point.x, point.y);
};
window.addEventListener('mousemove', handlePointerMove);
worldWrapEl.addEventListener('mouseleave', hidePlacementGhost);

worldWrapEl.addEventListener('mousedown', (e) => {
  const target = e.target instanceof Element ? e.target : null;
  const hitEntity = !!target?.closest('.entity');
  const panWithPrimary = e.button === 0 && !state.placementMode && !hitEntity;
  if (e.button === 2 || e.button === 1 || (e.button === 0 && e.shiftKey) || panWithPrimary) {
    e.preventDefault();
    state.cameraDrag = {
      active:true,
      startX:e.clientX,
      startY:e.clientY,
      originX:state.camera.x,
      originY:state.camera.y
    };
  }
});
worldWrapEl.addEventListener('contextmenu', (e) => {
  if (state.cameraDrag.active || e.target === worldWrapEl || worldWrapEl.contains(e.target)) e.preventDefault();
});

window.addEventListener('mouseup', async () => {
  if (state.draggingEntity && state.draggingMoved) {
    state.suppressWorldClick = true;
    try { await persistDraggedEntityPosition(state.draggingEntity); } catch {}
    await persistNow();
  }
  state.cameraDrag.active = false;
  state.draggingEntity = null;
  state.draggingMoved = false;
});

worldEl.addEventListener('click', (e) => {
  if (state.placementMode) {
    const point = localPointInWorld(e);
    const snapped = snapPlacement(state.placementMode, point.x, point.y);
    if (state.placementMode === 'base') placeBaseAt(snapped.x, snapped.y);
    if (state.placementMode === 'feature') placeFeatureAt(snapped.x, snapped.y);
    state.suppressWorldClick = false;
    setPlacement(null);
    return;
  }
  if (state.suppressWorldClick) {
    state.suppressWorldClick = false;
    return;
  }
});

boot();
updateCameraVisuals();
setInterval(async () => {
  const runsChanged = await refreshRuntimeState(false);
  if (!state.liveStream) startLiveStream();
  if (runsChanged) rebuildScene();
  else if (Number(state.live?.runningAgentCount || 0) > 0) {
    ensureMotionLoop();
    renderUnitsLiveState();
  } else renderUnitsLiveState();
  renderLiveConsole();
}, 2000);

window.addEventListener('beforeunload', () => {
  if (state.motionTimer) {
    clearInterval(state.motionTimer);
    state.motionTimer = null;
  }
  if (state.liveStream) {
    try { state.liveStream.close(); } catch {}
    state.liveStream = null;
  }
});
</script>
</body>
</html>
